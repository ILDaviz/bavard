The following text is a collection of source code files from a software project. Each file is delimited by a header line starting with "--- FILE: [filepath]".
Use only this content as the source of truth when answering questions.

The project structure is as follows:
bavard/
â”œâ”€â”€ build.yaml
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ bavard.dart
â”‚   â”œâ”€â”€ schema.dart
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”œâ”€â”€ concerns
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_attribute_helpers.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_casts.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_events.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_global_scopes.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_guards_attributes.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_relationships.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_soft_deletes.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ has_timestamps.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ has_uuids.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ database_adapter.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ database_manager.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ exceptions.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ grammar.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ model.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ query_builder.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ scope.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ typed_query.dart
â”‚   â”‚   â”‚   â””â”€â”€ utils.dart
â”‚   â”‚   â”œâ”€â”€ generators
â”‚   â”‚   â”‚   â”œâ”€â”€ annotations.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ builder.dart
â”‚   â”‚   â”‚   â””â”€â”€ orm_cast_type.dart
â”‚   â”‚   â”œâ”€â”€ grammars
â”‚   â”‚   â”‚   â”œâ”€â”€ postgres_grammar.dart
â”‚   â”‚   â”‚   â””â”€â”€ sqlite_grammar.dart
â”‚   â”‚   â”œâ”€â”€ relations
â”‚   â”‚   â”‚   â”œâ”€â”€ belongs_to.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ belongs_to_many.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ has_many.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ has_many_through.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ has_one.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ morph_many.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ morph_one.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ morph_to.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ morph_to_many.dart
â”‚   â”‚   â”‚   â””â”€â”€ relation.dart
â”‚   â”‚   â”œâ”€â”€ schema
â”‚   â”‚   â”‚   â””â”€â”€ columns.dart
â”‚   â”‚   â””â”€â”€ test
â”‚   â”‚       â””â”€â”€ mock_database.dart
â”‚   â””â”€â”€ testing.dart
â”œâ”€â”€ pubspec.yaml
â””â”€â”€ test
    â”œâ”€â”€ bavard_core_test.dart
    â”œâ”€â”€ core
    â”‚   â”œâ”€â”€ concerns
    â”‚   â”‚   â”œâ”€â”€ has_casts_test.dart
    â”‚   â”‚   â”œâ”€â”€ has_global_scopes_extended_test.dart
    â”‚   â”‚   â”œâ”€â”€ has_global_scopes_test.dart
    â”‚   â”‚   â”œâ”€â”€ has_guards_attributes_extended_test.dart
    â”‚   â”‚   â”œâ”€â”€ has_guards_attributes_test.dart
    â”‚   â”‚   â”œâ”€â”€ has_soft_deletes_extended_test.dart
    â”‚   â”‚   â”œâ”€â”€ has_soft_deletes_test.dart
    â”‚   â”‚   â”œâ”€â”€ has_timestamps_test.dart
    â”‚   â”‚   â””â”€â”€ has_uuids_test.dart
    â”‚   â”œâ”€â”€ database_manager_test.dart
    â”‚   â”œâ”€â”€ exceptions_test.dart
    â”‚   â”œâ”€â”€ group_by_having_test.dart
    â”‚   â”œâ”€â”€ lifecycle_hooks_test.dart
    â”‚   â”œâ”€â”€ model_crud_test.dart
    â”‚   â”œâ”€â”€ model_operators_test.dart
    â”‚   â”œâ”€â”€ model_save_failure_test.dart
    â”‚   â”œâ”€â”€ query_builder_test.dart
    â”‚   â”œâ”€â”€ query_builder_validation_test.dart
    â”‚   â”œâ”€â”€ transaction_test.dart
    â”‚   â”œâ”€â”€ typed_query_applies_model_newquery_test.dart
    â”‚   â”œâ”€â”€ typed_query_test.dart
    â”‚   â”œâ”€â”€ utils_test.dart
    â”‚   â””â”€â”€ watch_test.dart
    â”œâ”€â”€ relations
    â”‚   â”œâ”€â”€ belongs_to_many_extended_test.dart
    â”‚   â”œâ”€â”€ belongs_to_many_test.dart
    â”‚   â”œâ”€â”€ belongs_to_test.dart
    â”‚   â”œâ”€â”€ has_many_soft_delete_test.dart
    â”‚   â”œâ”€â”€ has_many_test.dart
    â”‚   â”œâ”€â”€ has_many_through_extended_test.dart
    â”‚   â”œâ”€â”€ has_many_through_test.dart
    â”‚   â”œâ”€â”€ has_one_test.dart
    â”‚   â”œâ”€â”€ morph_extended_test.dart
    â”‚   â”œâ”€â”€ morph_many_test.dart
    â”‚   â”œâ”€â”€ morph_one_test.dart
    â”‚   â”œâ”€â”€ morph_to_extended_test.dart
    â”‚   â”œâ”€â”€ morph_to_many_extended_test.dart
    â”‚   â”œâ”€â”€ morph_to_many_test.dart
    â”‚   â”œâ”€â”€ morph_to_test.dart
    â”‚   â”œâ”€â”€ relations_extended_test.dart
    â”‚   â””â”€â”€ relations_test.dart
    â””â”€â”€ schema
        â””â”€â”€ columns_test.dart

<<<

--- FILE: pubspec.yaml ---
name: bavard
description: A Laravel Eloquent-like ORM for PowerSync, sqlite or PostgreSQL.

version: 0.0.2

environment:
  sdk: ^3.10.1

dependencies:
  uuid: ^4.5.2

dev_dependencies:
  test: ^1.24.0
  lints: ^2.0.0
  build_runner: ^2.10.4
  source_gen: ^4.1.1
  analyzer: ^9.0.0

--- FILE: build.yaml ---
targets:
  $default:
    builders:
      bavard|fillable_generator:
        enabled: true
        generate_for:
          - lib/**/*.dart
          - test/**/*.dart

builders:
  fillable_generator:
    import: "package:bavard/src/generators/builder.dart"
    builder_factories: ["fillableGenerator"]
    build_extensions:
      ".dart": [".fillable.g.dart"]
    auto_apply: dependents
    build_to: source


--- FILE: test/bavard_core_test.dart ---
import 'dart:async';
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';

class MockDatabaseAdapter implements DatabaseAdapter {
  final List<Map<String, dynamic>> _mockData;

  MockDatabaseAdapter(this._mockData);

  // Default grammar
  final Grammar _grammar = SQLiteGrammar();

  @override
  Grammar get grammar => _grammar;

  @override
  Future<List<Map<String, dynamic>>> getAll(
    String sql, [
    List<dynamic>? arguments,
  ]) async {
    if (sql.contains('FROM "users"')) {
      return _mockData;
    }
    return [];
  }

  @override
  Future<Map<String, dynamic>> get(
    String sql, [
    List<dynamic>? arguments,
  ]) async {
    if (sql.contains('last_insert_row_id')) {
      return {'id': 1};
    }
    return _mockData.first;
  }

  @override
  Future<int> execute(String sql, [List<dynamic>? arguments]) async {
    return 1;
  }

  @override
  Stream<List<Map<String, dynamic>>> watch(
    String sql, {
    List<dynamic>? parameters,
  }) {
    return Stream.value(_mockData);
  }

  @override
  Future<dynamic> insert(String table, Map<String, dynamic> values) async {
    return 1;
  }

  @override
  bool get supportsTransactions => true;

  @override
  Future<T> transaction<T>(
    Future<T> Function(TransactionContext txn) callback,
  ) async {
    final context = _MockTransactionContext(this);
    return await callback(context);
  }
}

class _MockTransactionContext implements TransactionContext {
  final MockDatabaseAdapter _adapter;

  _MockTransactionContext(this._adapter);

  @override
  Future<List<Map<String, dynamic>>> getAll(
    String sql, [
    List<dynamic>? arguments,
  ]) {
    return _adapter.getAll(sql, arguments);
  }

  @override
  Future<Map<String, dynamic>> get(String sql, [List<dynamic>? arguments]) {
    return _adapter.get(sql, arguments);
  }

  @override
  Future<int> execute(String sql, [List<dynamic>? arguments]) {
    return _adapter.execute(sql, arguments);
  }

  @override
  Future<dynamic> insert(String table, Map<String, dynamic> values) {
    return _adapter.insert(table, values);
  }
}

class User extends Model {
  @override
  String get table => 'users';

  User([super.attributes]);

  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

void main() {
  setUp(() {
    final mockDb = MockDatabaseAdapter([
      {'id': 1, 'name': 'David', 'role': 'Admin'},
      {'id': 2, 'name': 'Romolo', 'role': 'Admin'},
    ]);
    DatabaseManager().setDatabase(mockDb);
  });

  group('ActiveSync Core Tests', () {
    test('It creates and hydrates typed models from query', () async {
      final List<User> users = await User().query().get();

      expect(users.length, 2);
      expect(users.first, isA<User>());
      expect(users.first.attributes['name'], 'David');
      expect(users.last.attributes['role'], 'Admin');
    });

    test('It manages dirty attributes correctly', () async {
      final user = User({'id': 1, 'name': 'David', 'email': 'old@test.com'});
      user.syncOriginal();

      expect(user.original['email'], 'old@test.com');

      user.attributes['email'] = 'new@test.com';

      final dirtyMap = <String, dynamic>{};
      user.attributes.forEach((key, value) {
        if (value != user.original[key]) {
          dirtyMap[key] = value;
        }
      });

      expect(dirtyMap.containsKey('email'), true);
      expect(dirtyMap.containsKey('name'), false);
    });
  });
}


--- FILE: lib/schema.dart ---
export 'src/schema/columns.dart';


--- FILE: lib/bavard.dart ---
/// Main entry point for the Bavard ORM library.
///
/// Exposes the core [Model], [QueryBuilder], [DatabaseManager], and relationship classes
/// required to interact with the database using the Active Record pattern.

/// Annotations for code generation and type casting definitions.
export 'src/generators/annotations.dart';
export 'src/generators/orm_cast_type.dart';

/// Core Active Record implementation and type-safe query extensions.
export 'src/core/model.dart';
export 'src/core/utils.dart';
export 'src/core/typed_query.dart';

/// Custom exception types for error handling.
export 'src/core/exceptions.dart';

/// Reusable model behaviors (Mixins) for UUIDs, timestamps, soft deletes, and global scopes.
export 'src/core/concerns/has_global_scopes.dart';
export 'src/core/scope.dart';
export 'src/core/concerns/has_uuids.dart';
export 'src/core/concerns/has_soft_deletes.dart';
export 'src/core/concerns/has_timestamps.dart';
export 'src/core/concerns/has_guards_attributes.dart';


/// Database connection management singleton and driver interface definitions.
export 'src/core/database_manager.dart';
export 'src/core/database_adapter.dart';

/// Fluent SQL query builder implementation.
export 'src/core/query_builder.dart';
export 'src/core/grammar.dart';
export 'src/grammars/sqlite_grammar.dart';
export 'src/grammars/postgres_grammar.dart';

/// Relationship definitions (One-to-One, One-to-Many, Many-to-Many, and Polymorphic).
export 'src/relations/relation.dart';
export 'src/relations/belongs_to.dart';
export 'src/relations/belongs_to_many.dart';
export 'src/relations/has_many.dart';
export 'src/relations/has_many_through.dart';
export 'src/relations/has_one.dart';
export 'src/relations/morph_many.dart';
export 'src/relations/morph_one.dart';
export 'src/relations/morph_to.dart';
export 'src/relations/morph_to_many.dart';


--- FILE: lib/testing.dart ---
export 'src/test/mock_database.dart';


--- FILE: lib/src/core/grammar.dart ---
import 'query_builder.dart';

class RawExpression {
  final String value;
  const RawExpression(this.value);
  @override
  String toString() => value;
}

abstract class Grammar {
  /// Compiles a SELECT query into a SQL string.
  String compileSelect(QueryBuilder query);

  /// Compiles an INSERT query into a SQL string.
  String compileInsert(QueryBuilder query, Map<String, dynamic> values);

  /// Compiles an UPDATE query into a SQL string.
  String compileUpdate(QueryBuilder query, Map<String, dynamic> values);

  /// Compiles a DELETE query into a SQL string.
  String compileDelete(QueryBuilder query);

  /// Wraps a value (table or column name) in quotes.
  String wrap(String value);

  /// Wraps an array of values.
  List<String> wrapArray(List<String> values) => values.map(wrap).toList();

  /// Returns a parameter placeholder.
  String parameter(dynamic value);

  /// Normalizes bindings for the specific database driver.
  List<dynamic> prepareBindings(List<dynamic> bindings);

  /// Concatenates components of a SELECT query.
  String concatenate(List<String> components) {
    return components.where((component) => component.isNotEmpty).join(' ');
  }

  /// Compiles components for a SELECT query.
  /// Subclasses can override this to change the order or components.
  List<String> compileComponents(QueryBuilder query) {
    return [
      'SELECT',
      compileColumns(query, query.columns),
      'FROM',
      wrap(query.table),
      ...compileJoins(query, query.joins),
      compileWheres(query),
      compileGroups(query, query.groups),
      compileHavings(query),
      compileOrders(query, query.orders),
      compileLimit(query, query.limitValue),
      compileOffset(query, query.offsetValue),
    ];
  }

  String compileColumns(QueryBuilder query, List<dynamic> columns) {
    final needsPrefixing = query.joins.isNotEmpty;

    return columns.map((column) {
      if (column is RawExpression) return column.value;
      
      final colStr = column.toString();
      if (colStr == '*') return '${wrap(query.table)}.*';

      if (colStr.toLowerCase().contains(' as ')) {
        final parts = colStr.split(RegExp(r'\s+as\s+', caseSensitive: false));
        if (parts.length == 2) {
          return '${wrap(parts[0])} AS ${wrap(parts[1])}';
        }
      }
      
      if (needsPrefixing && !colStr.contains('.') && !colStr.contains('(')) {
         return wrap('${query.table}.$colStr');
      }
      
      return wrap(colStr);
    }).join(', ');
  }

  List<String> compileJoins(QueryBuilder query, List<String> joins) {
    return joins; // Joins are currently stored as raw strings in QueryBuilder
  }

  String compileWheres(QueryBuilder query) {
    if (query.wheres.isEmpty) return '';

    final sql = query.wheres.map((where) {
      final boolean = where['type'];
      final querySql = where['sql'];
      return '$boolean $querySql';
    }).join(' ');
    
    // Remove the leading logic operator (AND/OR)
    return 'WHERE ' + sql.replaceFirst(RegExp(r'^(AND|OR)\s+'), '');
  }

  String compileGroups(QueryBuilder query, List<String> groups) {
    if (groups.isEmpty) return '';
    return 'GROUP BY ' + groups.map(wrap).join(', ');
  }

  String compileHavings(QueryBuilder query) {
    if (query.havings.isEmpty) return '';

    final sql = query.havings.map((having) {
      final boolean = having['type'];
      final querySql = having['sql'];
      return '$boolean $querySql';
    }).join(' ');

    return 'HAVING ' + sql.replaceFirst(RegExp(r'^(AND|OR)\s+'), '');
  }

  String compileOrders(QueryBuilder query, String? orderBy) {
    if (orderBy == null) return '';
    return 'ORDER BY $orderBy';
  }

  String compileLimit(QueryBuilder query, int? limit) {
    if (limit == null) return '';
    return 'LIMIT $limit';
  }

  String compileOffset(QueryBuilder query, int? offset) {
    if (offset == null) return '';
    return 'OFFSET $offset';
  }
}


--- FILE: lib/src/core/database_adapter.dart ---
import 'grammar.dart';

/// Protocol for database drivers.
///
/// Abstraction layer that decouples the ORM from specific SQL dialects (SQLite, Postgres)
/// or underlying packages (sqflite, drift).
abstract class DatabaseAdapter {
  /// Returns the query grammar used by this adapter.
  Grammar get grammar;

  /// Executes a SELECT query.
  ///
  /// Implementations MUST support variable binding in [arguments] to prevent SQL injection.
  Future<List<Map<String, dynamic>>> getAll(
    String sql, [
    List<dynamic>? arguments,
  ]);

  /// Executes non-selecting commands (UPDATE, DELETE) or schema changes (DDL).
  Future<int> execute(String sql, [List<dynamic>? arguments]);

  /// Convenience wrapper to fetch the first result of a query.
  Future<Map<String, dynamic>> get(String sql, [List<dynamic>? arguments]);

  /// Inserts a record and returns the auto-generated primary key (if applicable).
  Future<dynamic> insert(String table, Map<String, dynamic> values);

  /// Exposes a reactive stream of query results.
  ///
  /// Critical for Flutter integration: implementations should emit a new event
  /// whenever the data targeted by [sql] is modified, triggering UI rebuilds.
  Stream<List<Map<String, dynamic>>> watch(
    String sql, {
    List<dynamic>? parameters,
  });

  // ---------------------------------------------------------------------------
  // TRANSACTION SUPPORT
  // ---------------------------------------------------------------------------

  /// Executes a callback within a database transaction.
  ///
  /// If [callback] throws an exception, the transaction MUST be rolled back.
  /// If [callback] completes successfully, the transaction MUST be committed.
  ///
  /// Implementations should support nested transactions via savepoints where available.
  ///
  /// Returns the result of [callback].
  ///
  /// Example:
  /// ```dart
  /// final result = await db.transaction((txn) async {
  ///   await txn.execute('INSERT INTO users (name) VALUES (?)', ['David']);
  ///   await txn.execute('INSERT INTO profiles (user_id) VALUES (?)', [1]);
  ///   return 'success';
  /// });
  /// ```
  Future<T> transaction<T>(Future<T> Function(TransactionContext txn) callback);

  /// Indicates whether the adapter supports transactions.
  ///
  /// Some adapters (e.g., in-memory mocks) may not support transactions.
  /// Use this to conditionally enable transactional features.
  bool get supportsTransactions => true;
}

/// Context object passed to transaction callbacks.
///
/// Provides the same API as [DatabaseAdapter] but executes within the
/// transaction boundary. Implementations should ensure all operations
/// through this context participate in the active transaction.
abstract class TransactionContext {
  /// Executes a SELECT query within the transaction.
  Future<List<Map<String, dynamic>>> getAll(
    String sql, [
    List<dynamic>? arguments,
  ]);

  /// Executes non-selecting commands within the transaction.
  Future<int> execute(String sql, [List<dynamic>? arguments]);

  /// Fetches the first result within the transaction.
  Future<Map<String, dynamic>> get(String sql, [List<dynamic>? arguments]);

  /// Inserts a record within the transaction.
  Future<dynamic> insert(String table, Map<String, dynamic> values);
}


--- FILE: lib/src/core/utils.dart ---
/// Helpers for ORM 'Convention over Configuration' naming resolution.
class Utils {
  /// Heuristic-based plural-to-singular conversion.
  ///
  /// **Trade-off**: Naive implementation for performance/size. Handles standard
  /// suffixes ('ies', 's') but does not support irregular English plurals (e.g., 'mice').
  static String singularize(String word) {
    if (word.endsWith('ies')) {
      return '${word.substring(0, word.length - 3)}y';
    }
    if (word.endsWith('s') && !word.endsWith('ss')) {
      return word.substring(0, word.length - 1);
    }

    return word;
  }

  /// Infers foreign key column name from a table name (e.g., `users` -> `user_id`).
  static String foreignKey(String tableName) {
    return '${singularize(tableName)}_id';
  }
}


--- FILE: lib/src/core/scope.dart ---
import 'query_builder.dart';
import 'model.dart';

/// Interface for cross-cutting query constraints (e.g., SoftDeletes, Multi-tenancy).
///
/// Global scopes intercept the `QueryBuilder` lifecycle to inject invariants
/// (WHERE clauses) before query execution.
abstract class Scope {
  /// Modifies [builder] to enforce the scope's constraints on the target [model].
  void apply(QueryBuilder builder, Model model);
}


--- FILE: lib/src/core/exceptions.dart ---
/// Base exception for all ORM-related errors.
///
/// Provides a common ancestor for catching any Bavard exception
/// while allowing specific handling via subclasses.
abstract class BavardException implements Exception {
  final String message;
  final dynamic originalError;

  const BavardException(this.message, [this.originalError]);

  @override
  String toString() => 'ActiveSyncException: $message';
}

/// Thrown when a requested model cannot be found in the database.
///
/// Typically raised by `findOrFail()` or `firstOrFail()` when no matching
/// record exists.
class ModelNotFoundException extends BavardException {
  final String model;
  final dynamic id;

  const ModelNotFoundException({required this.model, this.id, String? message})
    : super(
        message ??
            'No query results for model [$model]${id != null ? ' with ID: $id' : ''}.',
      );

  @override
  String toString() => 'ModelNotFoundException: $message';
}

/// Thrown when a database query fails to execute.
///
/// Wraps the underlying driver exception with additional context
/// about the failing SQL statement.
class QueryException extends BavardException {
  final String sql;
  final List<dynamic>? bindings;

  const QueryException({
    required this.sql,
    this.bindings,
    required String message,
    dynamic originalError,
  }) : super(message, originalError);

  @override
  String toString() =>
      'QueryException: $message\nSQL: $sql\nBindings: $bindings';
}

/// Thrown when a database transaction fails.
///
/// Contains information about whether the transaction was rolled back
/// and the original cause of failure.
class TransactionException extends BavardException {
  final bool wasRolledBack;

  const TransactionException({
    required String message,
    this.wasRolledBack = true,
    dynamic originalError,
  }) : super(message, originalError);

  @override
  String toString() =>
      'TransactionException: $message (Rolled back: $wasRolledBack)';
}

/// Thrown when attempting to use the database before initialization.
///
/// Signals that `DatabaseManager().setDatabase()` was not called.
class DatabaseNotInitializedException extends BavardException {
  const DatabaseNotInitializedException()
    : super(
        'Database driver not initialized. '
        'Call DatabaseManager().setDatabase(driver) first.',
      );

  @override
  String toString() => 'DatabaseNotInitializedException: $message';
}

/// Thrown when mass assignment protection blocks an attribute.
///
/// Useful for debugging when `fill()` silently ignores fields.
class MassAssignmentException extends BavardException {
  final String attribute;
  final String model;

  const MassAssignmentException({required this.attribute, required this.model})
    : super('Cannot mass-assign [$attribute] on model [$model].');

  @override
  String toString() => 'MassAssignmentException: $message';
}

/// Thrown when an invalid query structure is detected.
///
/// Examples: Invalid operator, malformed identifier, or conflicting clauses.
class InvalidQueryException extends BavardException {
  const InvalidQueryException(String message) : super(message);

  @override
  String toString() => 'InvalidQueryException: $message';
}

/// Thrown when a relationship cannot be resolved.
///
/// May occur due to missing foreign keys, invalid type maps (MorphTo),
/// or undefined relation methods.
class RelationNotFoundException extends BavardException {
  final String relation;
  final String model;

  const RelationNotFoundException({required this.relation, required this.model})
    : super('Relation [$relation] not found on model [$model].');

  @override
  String toString() => 'RelationNotFoundException: $message';
}


--- FILE: lib/src/core/database_manager.dart ---
import 'database_adapter.dart';
import 'exceptions.dart';

/// Singleton service locator for the active database connection.
///
/// Decouples the application logic from specific database drivers, allowing
/// the active adapter to be injected at runtime (Service Locator pattern).
class DatabaseManager {
  static final DatabaseManager _instance = DatabaseManager._internal();

  DatabaseAdapter? _db;

  /// Tracks the current transaction context for nested operations.
  TransactionContext? _activeTransaction;

  factory DatabaseManager() => _instance;

  DatabaseManager._internal();

  /// Dependency injection entry point.
  ///
  /// Must be invoked during app initialization (e.g., in `main()`) prior
  /// to any model operations.
  void setDatabase(DatabaseAdapter db) {
    _db = db;
  }

  /// Fail-fast accessor for the active driver.
  ///
  /// Throws [DatabaseNotInitializedException] if [setDatabase] was not called.
  DatabaseAdapter get db {
    if (_db == null) {
      throw const DatabaseNotInitializedException();
    }
    return _db!;
  }

  /// Returns the active transaction context if within a transaction, null otherwise.
  TransactionContext? get activeTransaction => _activeTransaction;

  /// Indicates whether code is currently executing within a transaction.
  bool get inTransaction => _activeTransaction != null;

  // ---------------------------------------------------------------------------
  // TRANSACTION API
  // ---------------------------------------------------------------------------

  /// Executes [callback] within a database transaction.
  ///
  /// Automatically rolls back on exception and commits on success.
  /// Supports nested transactions via the adapter's implementation.
  ///
  /// Throws [TransactionException] if the transaction fails.
  ///
  /// Example:
  /// ```dart
  /// await DatabaseManager().transaction((txn) async {
  ///   final user = User({'name': 'David'});
  ///   await user.save(); // Uses the active transaction
  ///
  ///   final profile = Profile({'user_id': user.id});
  ///   await profile.save();
  ///
  ///   return user;
  /// });
  /// ```
  Future<T> transaction<T>(
    Future<T> Function(TransactionContext txn) callback,
  ) async {
    if (!db.supportsTransactions) {
      throw const TransactionException(
        message: 'The current database adapter does not support transactions.',
        wasRolledBack: false,
      );
    }

    try {
      return await db.transaction<T>((txn) async {
        // Store the transaction context for Model operations
        final previousTransaction = _activeTransaction;
        _activeTransaction = txn;

        try {
          final result = await callback(txn);
          return result;
        } finally {
          // Restore the previous transaction context (for nested transactions)
          _activeTransaction = previousTransaction;
        }
      });
    } catch (e) {
      if (e is TransactionException) rethrow;

      throw TransactionException(
        message: 'Transaction failed: ${e.toString()}',
        wasRolledBack: true,
        originalError: e,
      );
    }
  }

  /// Executes SQL using the active transaction if available, otherwise uses the main connection.
  ///
  /// Returns the number of rows affected (if supported by the adapter).
  Future<int> execute(String sql, [List<dynamic>? arguments]) async {
    if (_activeTransaction != null) {
      return await _activeTransaction!.execute(sql, arguments);
    } else {
      return await db.execute(sql, arguments);
    }
  }

  /// Fetches all results using the active transaction if available.
  Future<List<Map<String, dynamic>>> getAll(
    String sql, [
    List<dynamic>? arguments,
  ]) async {
    if (_activeTransaction != null) {
      return await _activeTransaction!.getAll(sql, arguments);
    }
    return await db.getAll(sql, arguments);
  }

  /// Fetches a single result using the active transaction if available.
  Future<Map<String, dynamic>> get(
    String sql, [
    List<dynamic>? arguments,
  ]) async {
    if (_activeTransaction != null) {
      return await _activeTransaction!.get(sql, arguments);
    }
    return await db.get(sql, arguments);
  }

  /// Inserts a record using the active transaction if available.
  Future<dynamic> insert(String table, Map<String, dynamic> values) async {
    if (_activeTransaction != null) {
      return await _activeTransaction!.insert(table, values);
    }
    return await db.insert(table, values);
  }
}


--- FILE: lib/src/core/query_builder.dart ---
import 'dart:async';
import 'package:bavard/schema.dart';
import '../../bavard.dart';

typedef ScopeCallback = void Function(QueryBuilder builder);

/// Fluent interface for constructing type-safe SQL queries and hydrating results into [Model] instances.
///
/// Abstracts raw SQL generation, manages parameter binding for security (SQL injection prevention),
/// and handles the object lifecycle (hydration, dirty checking initialization) and eager loading.
class QueryBuilder<T extends Model> {
  final String table;
  final T Function(Map<String, dynamic>) creator;

  /// Internal factory for empty instances (used during generic casting or hydration).
  final T Function() _instanceFactory;

  final List<Map<String, dynamic>> _wheres = [];
  final List<dynamic> _bindings = [];
  final List<String> _joins = [];
  final List<String> _with = [];
  List<dynamic> _columns = ['*'];

  final List<String> _groupBy = [];
  final List<Map<String, dynamic>> _havings = [];
  final List<dynamic> _havingBindings = [];

  final Map<String, ScopeCallback> _globalScopes = {};
  bool _ignoreGlobalScopes = false;

  int? _offset;
  String? _orderBy;
  int? _limit;

  /// Validates [table] immediately to prevent identifier injection attacks.
  QueryBuilder(this.table, this.creator, {T Function()? instanceFactory})
    : _instanceFactory =
          instanceFactory ?? (() => creator(const {}).newInstance() as T) {
    _assertIdent(table, dotted: false, what: 'table name');
  }

  /// Helper to access the current database grammar.
  Grammar get _grammar => DatabaseManager().db.grammar;

  // Public getters for Grammar access
  List<Map<String, dynamic>> get wheres => _wheres;
  List<dynamic> get columns => _columns;
  List<String> get joins => _joins;
  List<String> get groups => _groupBy;
  List<Map<String, dynamic>> get havings => _havings;
  String? get orders => _orderBy;
  int? get limitValue => _limit;
  int? get offsetValue => _offset;

  /// Returns the raw SQL string compiled from current state.
  String toSql() => _compileSql();

  static final RegExp _tableIdent = RegExp(r'^[A-Za-z_][A-Za-z0-9_]*$');

  static final RegExp _dottedIdent = RegExp(
    r'^[A-Za-z_][A-Za-z0-9_]*(\.[A-Za-z_][A-Za-z0-9_]*)*$',
  );

  static const Set<String> _allowedWhereOps = {
    '=',
    '!=',
    '<>',
    '>',
    '<',
    '>=',
    '<=',
    'LIKE',
    'NOT LIKE',
  };

  static const Set<String> _allowedJoinOps = {
    '=',
    '!=',
    '<>',
    '>',
    '<',
    '>=',
    '<=',
  };

  static const Set<String> _allowedHavingOps = {
    '=',
    '!=',
    '<>',
    '>',
    '<',
    '>=',
    '<=',
  };

  static String _operator(String op) => op.trim().toUpperCase();

  /// Security Check: Ensures identifiers (tables, columns) match a strict regex.
  ///
  /// Necessary because identifiers cannot be parameterized in SQL, making them
  /// vulnerable to injection if not sanitized.
  static void _assertIdent(
    String v, {
    required bool dotted,
    required String what,
  }) {
    final ok = dotted ? _dottedIdent.hasMatch(v) : _tableIdent.hasMatch(v);
    if (!ok) {
      throw InvalidQueryException('Invalid $what: $v');
    }
  }

  // ---------------------------------------------------------------------------
  // DEBUGGING TOOLS
  // ---------------------------------------------------------------------------

  String toRawSql() {
    String sql = _compileSql();
    final allBindings = _grammar.prepareBindings([..._bindings, ..._havingBindings]);

    int index = 0;
    return sql.replaceAllMapped('?', (match) {
      if (index >= allBindings.length) return '?';

      final value = allBindings[index++];
      return _formatValueForDebug(value);
    });
  }

  String _formatValueForDebug(dynamic value) {
    if (value == null) return 'NULL';
    if (value is num) return value.toString();
    if (value is bool) return value ? '1' : '0';
    if (value is DateTime) return "'${value.toIso8601String()}'";
    return "'${value.toString().replaceAll("'", "''")}'";
  }

  QueryBuilder<T> printRawSql() {
    print('\x1B[35m[RAW SQL]\x1B[0m ${toRawSql()}');
    return this;
  }

  QueryBuilder<T> printQueryAndBindings() {
    print('\x1B[34m[QUERY]\x1B[0m ${_compileSql()}');
    print('\x1B[33m[BINDINGS]\x1B[0m ${[..._bindings, ..._havingBindings]}');
    return this;
  }

  void printAndDieRawSql() {
    printRawSql();
    throw Exception('ðŸ›‘ DIE PRINT RAW SQL EXECUTED');
  }

  // ---------------------------------------------------------------------------
  // SCOPE
  // ---------------------------------------------------------------------------

  QueryBuilder<T> withGlobalScope(String name, ScopeCallback scope) {
    _globalScopes[name] = scope;
    return this;
  }

  QueryBuilder<T> withoutGlobalScopes() {
    _ignoreGlobalScopes = true;
    return this;
  }

  QueryBuilder<T> withoutGlobalScope(String name) {
    _globalScopes.remove(name);
    return this;
  }

  void _applyScopes() {
    if (_ignoreGlobalScopes) return;

    _globalScopes.forEach((name, scope) {
      scope(this);
    });
  }

  // ---------------------------------------------------------------------------
  // WHERE CLAUSES (AND / OR)
  // ---------------------------------------------------------------------------

  /// Appends a condition to the query state.
  ///
  /// Validates [operator] against a whitelist to prevent logic injection.
  QueryBuilder<T> where(
      dynamic column, [
        dynamic value,
        String operator = '=',
        String boolean = 'AND',
      ]) {

    String targetColumn;
    String targetOperator;
    dynamic targetValue;
    String targetBoolean = boolean;

    if (column is WhereCondition) {
      targetColumn = column.column;
      targetOperator = column.operator;
      targetValue = column.value;
      targetBoolean = column.boolean;
    } else {
      if (column is Column) {
        targetColumn = column.name!;
      } else {
        targetColumn = column.toString();
      }
      targetOperator = operator;
      targetValue = value;
    }

    _assertIdent(targetColumn, dotted: true, what: 'column name');

    if (targetValue == null) {
      final checkOp = _operator(targetOperator);
      if (checkOp == '=') {
        return whereNull(targetColumn, boolean: targetBoolean);
      } else if (checkOp == '<>' || checkOp == '!=') {
        return whereNotNull(targetColumn, boolean: targetBoolean);
      }
    }

    final finalOp = _operator(targetOperator);
    if (!_allowedWhereOps.contains(finalOp)) {
      throw InvalidQueryException('Invalid operator for where: $targetOperator');
    }

    String sqlString;
    // We use _grammar.wrap for columns and _grammar.parameter for values

    if (finalOp == 'IN' || finalOp == 'NOT IN') {
      if (targetValue is! List) {
        throw ArgumentError(
            'QueryBuilder Error: L\'operatore "$finalOp" richiede una List come valore. '
                'Ricevuto: ${targetValue.runtimeType}'
        );
      }

      if (targetValue.isEmpty) {
        sqlString = '1 = 0';
      } else {
        final placeholders = List.filled(targetValue.length, _grammar.parameter(null)).join(', ');
        sqlString = '${_grammar.wrap(targetColumn)} $finalOp ($placeholders)';
        _bindings.addAll(targetValue);
      }
    }

    else if (finalOp == 'BETWEEN') {
      if (targetValue is! List || targetValue.length != 2) {
        throw ArgumentError(
            'QueryBuilder Error: L\'operatore "BETWEEN" richiede una List di esattamente 2 elementi [min, max].'
        );
      }
      sqlString = '${_grammar.wrap(targetColumn)} $finalOp ${_grammar.parameter(targetValue[0])} AND ${_grammar.parameter(targetValue[1])}';
      _bindings.addAll(targetValue);
    }

    else {
      if (targetValue is List) {
        throw ArgumentError(
            'QueryBuilder Error: Non puoi usare una List con l\'operatore "$finalOp". '
                'Usa IN, NOT IN o BETWEEN.'
        );
      }

      sqlString = '${_grammar.wrap(targetColumn)} $finalOp ${_grammar.parameter(targetValue)}';
      _bindings.add(targetValue);
    }

    _wheres.add({
      'type': targetBoolean,
      'sql': sqlString,
    });

    return this;
  }

  QueryBuilder<T> orWhere(
      dynamic column, [
        dynamic value,
        String operator = '=',
      ]) {

    return where(column, value, operator, 'OR');
  }

  /// Adds a nested WHERE group wrapped in parentheses: AND (...).
  ///
  /// Example:
  /// query.whereGroup((q) => q.where('a', 1).orWhere('b', 1))
  /// Generates: ... AND (a = 1 OR b = 1)
  QueryBuilder<T> whereGroup(void Function(QueryBuilder<T> query) callback) {
    return _addNestedWhere(callback, 'AND');
  }

  /// Adds a nested WHERE group wrapped in parentheses: OR (...).
  ///
  /// Example:
  /// query.orWhereGroup((q) => q.where('active', 1).where('age', '>', 18))
  /// Generates: ... OR (active = 1 AND age > 18)
  QueryBuilder<T> orWhereGroup(void Function(QueryBuilder<T> query) callback) {
    return _addNestedWhere(callback, 'OR');
  }

  /// Internal helper to process nested queries.
  QueryBuilder<T> _addNestedWhere(
    void Function(QueryBuilder<T> query) callback,
    String boolean,
  ) {
    final nestedBuilder = QueryBuilder<T>(
      table,
      creator,
      instanceFactory: _instanceFactory,
    );

    callback(nestedBuilder);

    final nestedClause = _grammar.compileWheres(nestedBuilder);

    if (nestedClause.isNotEmpty) {
      // Remove 'WHERE ' from the compiled string
      final sqlInside = nestedClause.substring(6);

      _wheres.add({'type': boolean, 'sql': '($sqlInside)'});

      _bindings.addAll(nestedBuilder._bindings);
    }

    return this;
  }

  QueryBuilder<T> whereNull(String column, {String boolean = 'AND'}) {
    _assertIdent(column, dotted: true, what: 'column name');
    _wheres.add({'type': boolean, 'sql': '${_grammar.wrap(column)} IS NULL'});
    return this;
  }

  QueryBuilder<T> orWhereNull(String column) {
    return whereNull(column, boolean: 'OR');
  }

  QueryBuilder<T> whereNotNull(String column, {String boolean = 'AND'}) {
    _assertIdent(column, dotted: true, what: 'column name');
    _wheres.add({'type': boolean, 'sql': '${_grammar.wrap(column)} IS NOT NULL'});
    return this;
  }

  QueryBuilder<T> orWhereNotNull(String column) {
    return whereNotNull(column, boolean: 'OR');
  }

  /// Appends an `IN` clause.
  ///
  /// Optimization: If [values] is empty, generates `0 = 1` to short-circuit the query safely.
  QueryBuilder<T> whereIn(
    String column,
    List<dynamic> values, {
    String boolean = 'AND',
  }) {
    _assertIdent(column, dotted: true, what: 'column name');
    if (values.isEmpty) {
      _wheres.add({'type': boolean, 'sql': '0 = 1'});
      return this;
    }

    final placeholders = List.filled(values.length, _grammar.parameter(null)).join(', ');
    _wheres.add({'type': boolean, 'sql': '${_grammar.wrap(column)} IN ($placeholders)'});
    _bindings.addAll(values);
    return this;
  }

  QueryBuilder<T> orWhereIn(String column, List<dynamic> values) {
    return whereIn(column, values, boolean: 'OR');
  }

  /// Nested query support via `EXISTS`.
  ///
  /// Merges the bindings of the sub-query [query] into the parent builder.
  QueryBuilder<T> whereExists(
    QueryBuilder query, {
    String boolean = 'AND',
    bool not = false,
  }) {
    final type = not ? 'NOT EXISTS' : 'EXISTS';
    final subSql = query.toSql();

    _wheres.add({'type': boolean, 'sql': '$type ($subSql)'});

    _bindings.addAll(query._bindings);
    return this;
  }

  QueryBuilder<T> orWhereExists(QueryBuilder query) {
    return whereExists(query, boolean: 'OR');
  }

  QueryBuilder<T> whereNotExists(QueryBuilder query) {
    return whereExists(query, not: true);
  }

  QueryBuilder<T> orWhereNotExists(QueryBuilder query) {
    return whereExists(query, boolean: 'OR', not: true);
  }

  /// Raw SQL escape hatch. Use with caution.
  ///
  /// [bindings] must be provided manually if user input is involved.
  QueryBuilder<T> whereRaw(
    String sql, {
    List<dynamic> bindings = const [],
    String boolean = 'AND',
  }) {
    _wheres.add({'type': boolean, 'sql': sql});
    _bindings.addAll(bindings);
    return this;
  }

  QueryBuilder<T> orWhereRaw(String sql, [List<dynamic> bindings = const []]) {
    return whereRaw(sql, bindings: bindings, boolean: 'OR');
  }

  // ---------------------------------------------------------------------------
  // GROUP BY / HAVING CLAUSES
  // ---------------------------------------------------------------------------

  /// Groups results by one or more columns.
  ///
  /// Essential for aggregate queries (COUNT, SUM, AVG) that need to partition
  /// results by specific attributes.
  ///
  /// Example:
  /// ```dart
  /// await User().query()
  ///   .select(['role', 'COUNT(*) as count'])
  ///   .groupBy(['role'])
  ///   .get();
  /// ```
  QueryBuilder<T> groupBy(List<String> columns) {
    for (final column in columns) {
      _assertIdent(column, dotted: true, what: 'groupBy column');
      _groupBy.add(column); // Grammar wraps these in compileGroups
    }
    return this;
  }

  /// Convenience method for grouping by a single column.
  QueryBuilder<T> groupByColumn(String column) {
    return groupBy([column]);
  }

  /// Adds a HAVING clause to filter grouped results.
  ///
  /// HAVING operates on aggregate results (post-GROUP BY), unlike WHERE
  /// which filters individual rows before grouping.
  ///
  /// Example:
  /// ```dart
  /// await Order().query()
  ///   .select(['customer_id', 'SUM(total) as total_spent'])
  ///   .groupBy(['customer_id'])
  ///   .having('SUM(total)', 1000, operator: '>')
  ///   .get();
  /// ```
  QueryBuilder<T> having(
    String column,
    dynamic value, {
    String operator = '=',
    String boolean = 'AND',
  }) {
    final op = _operator(operator);
    if (!_allowedHavingOps.contains(op)) {
      throw InvalidQueryException('Invalid operator for having: $operator');
    }

    final sqlCol = column.contains('(') ? column : _grammar.wrap(column);
    _havings.add({'type': boolean, 'sql': '$sqlCol $op ${_grammar.parameter(value)}'});
    _havingBindings.add(value);
    return this;
  }

  /// Adds an OR HAVING clause.
  QueryBuilder<T> orHaving(
    String column,
    dynamic value, {
    String operator = '=',
  }) {
    return having(column, value, operator: operator, boolean: 'OR');
  }

  /// Adds a raw HAVING clause for complex aggregate conditions.
  ///
  /// Use for expressions that cannot be represented with simple column comparisons.
  ///
  /// Example:
  /// ```dart
  /// await Product().query()
  ///   .select(['category', 'AVG(price) as avg_price'])
  ///   .groupBy(['category'])
  ///   .havingRaw('AVG(price) > ? AND COUNT(*) >= ?', bindings: [50, 10])
  ///   .get();
  /// ```
  QueryBuilder<T> havingRaw(
    String sql, {
    List<dynamic> bindings = const [],
    String boolean = 'AND',
  }) {
    _havings.add({'type': boolean, 'sql': sql});
    _havingBindings.addAll(bindings);
    return this;
  }

  /// Adds an OR raw HAVING clause.
  QueryBuilder<T> orHavingRaw(String sql, [List<dynamic> bindings = const []]) {
    return havingRaw(sql, bindings: bindings, boolean: 'OR');
  }

  /// Adds a HAVING clause that checks for NULL.
  QueryBuilder<T> havingNull(String column, {String boolean = 'AND'}) {
    final sqlCol = column.contains('(') ? column : _grammar.wrap(column);

    _havings.add({'type': boolean, 'sql': '$sqlCol IS NULL'});
    return this;
  }

  /// Adds a HAVING clause that checks for NOT NULL.
  QueryBuilder<T> havingNotNull(String column, {String boolean = 'AND'}) {
    final sqlCol = column.contains('(') ? column : _grammar.wrap(column);

    _havings.add({'type': boolean, 'sql': '$sqlCol IS NOT NULL'});
    return this;
  }

  /// Adds a HAVING BETWEEN clause.
  ///
  /// Useful for filtering aggregates within a range.
  QueryBuilder<T> havingBetween(
    String column,
    dynamic min,
    dynamic max, {
    String boolean = 'AND',
  }) {
    final sqlCol = column.contains('(') ? column : _grammar.wrap(column);
    _havings.add({
      'type': boolean,
      'sql': '$sqlCol BETWEEN ${_grammar.parameter(min)} AND ${_grammar.parameter(max)}'
    });
    _havingBindings.addAll([min, max]);
    return this;
  }

  // ---------------------------------------------------------------------------
  // SELECT & PROJECTION
  // ---------------------------------------------------------------------------

  QueryBuilder<T> select(List<String> columns) {
    _columns = List<dynamic>.from(columns);
    return this;
  }

  /// Adds aggregate columns to the selection without replacing existing columns.
  ///
  /// Convenience method for adding COUNT, SUM, etc. to the query.
  QueryBuilder<T> selectRaw(String expression) {
    if (_columns.length == 1 && _columns.first == '*') {
      _columns = [RawExpression(expression)];
    } else {
      _columns.add(RawExpression(expression));
    }
    return this;
  }

  // ---------------------------------------------------------------------------
  // AGGREGATES & HELPERS
  // ---------------------------------------------------------------------------

  /// Checks existence by fetching a single record (Limit 1 optimization).
  Future<bool> exists() async {
    final clone = cast<T>(creator, instanceFactory: _instanceFactory);
    clone.limit(1);
    final results = await clone.get();
    return results.isNotEmpty;
  }

  Future<bool> notExist() async {
    return !await exists();
  }

  Future<int?> count([String column = '*']) async {
    if (_groupBy.isNotEmpty || _havings.isNotEmpty) {
      final dbManager = DatabaseManager();
      final subQuery = _compileSql();
      final bindings = _grammar.prepareBindings([..._bindings, ..._havingBindings]);
      final wrapperSql =
          'SELECT COUNT(*) as aggregate FROM ($subQuery) as temp_table';
      try {
        final row = await dbManager.get(wrapperSql, bindings);
        if (row.isEmpty || row['aggregate'] == null) return 0;

        final value = row['aggregate'];
        return (value is num) ? value.toInt() : value as int;
      } catch (e) {
        throw QueryException(
          sql: wrapperSql,
          bindings: bindings,
          message: 'Failed to execute count with group by: ${e.toString()}',
          originalError: e,
        );
      }
    }

    return await _scalar<int>('COUNT($column)');
  }

  Future<num> sum(String column) async {
    _guardAgainstGrouping('sum');
    return await _scalar<num>('SUM($column)') ?? 0;
  }

  Future<double?> avg(String column) async {
    _guardAgainstGrouping('avg');
    final result = await _scalar('AVG($column)');
    return result != null ? (result as num).toDouble() : null;
  }

  Future<dynamic> max(String column) async {
    _guardAgainstGrouping('max');
    return await _scalar('MAX($column)');
  }

  Future<dynamic> min(String column) async {
    _guardAgainstGrouping('min');
    return await _scalar('MIN($column)');
  }

  void _guardAgainstGrouping(String method) {
    if (_groupBy.isNotEmpty || _havings.isNotEmpty) {
      throw QueryException(
        sql: _compileSql(),
        bindings: [],
        message:
            'Cannot use $method() with groupBy() or having(). '
            'This would return a single value from a list of groups, which is ambiguous or mathematically wrong. '
            'Use get() to retrieve grouped results.',
      );
    }
  }

  Future<T?> find(dynamic id) {
    final clone = cast<T>(creator, instanceFactory: _instanceFactory);
    return clone.where('id', id).first();
  }

  /// Finds a model by ID or throws [ModelNotFoundException].
  Future<T> findOrFail(dynamic id) async {
    final result = await find(id);
    if (result == null) {
      // Use the table name as a proxy for model name
      throw ModelNotFoundException(model: table, id: id);
    }
    return result;
  }

  /// Returns the first result or throws [ModelNotFoundException].
  Future<T> firstOrFail() async {
    final result = await first();
    if (result == null) {
      throw ModelNotFoundException(model: table);
    }
    return result;
  }

  // ---------------------------------------------------------------------------
  // JOINS & RELATIONS
  // ---------------------------------------------------------------------------

  QueryBuilder<T> join(String table, String one, String operator, String two) {
    _assertIdent(table, dotted: false, what: 'join table name');
    _assertIdent(one, dotted: true, what: 'join lhs');
    _assertIdent(two, dotted: true, what: 'join rhs');

    final op = _operator(operator);
    if (!_allowedJoinOps.contains(op)) {
      throw InvalidQueryException('Invalid operator for join: $operator');
    }

    _joins.add('JOIN ${_grammar.wrap(table)} ON ${_grammar.wrap(one)} $op ${_grammar.wrap(two)}');
    return this;
  }

  /// Adds a LEFT JOIN clause.
  QueryBuilder<T> leftJoin(
    String table,
    String one,
    String operator,
    String two,
  ) {
    _assertIdent(table, dotted: false, what: 'join table name');
    _assertIdent(one, dotted: true, what: 'join lhs');
    _assertIdent(two, dotted: true, what: 'join rhs');

    final op = _operator(operator);
    if (!_allowedJoinOps.contains(op)) {
      throw InvalidQueryException('Invalid operator for join: $operator');
    }

    _joins.add('LEFT JOIN ${_grammar.wrap(table)} ON ${_grammar.wrap(one)} $op ${_grammar.wrap(two)}');
    return this;
  }

  /// Adds a RIGHT JOIN clause.
  QueryBuilder<T> rightJoin(
    String table,
    String one,
    String operator,
    String two,
  ) {
    _assertIdent(table, dotted: false, what: 'join table name');
    _assertIdent(one, dotted: true, what: 'join lhs');
    _assertIdent(two, dotted: true, what: 'join rhs');

    final op = _operator(operator);
    if (!_allowedJoinOps.contains(op)) {
      throw InvalidQueryException('Invalid operator for join: $operator');
    }

    _joins.add('RIGHT JOIN ${_grammar.wrap(table)} ON ${_grammar.wrap(one)} $op ${_grammar.wrap(two)}');
    return this;
  }

  /// Queues relationships for eager loading after the main query execution.
  ///
  /// Critical for performance optimization (mitigates N+1 queries).
  QueryBuilder<T> withRelations(List<String> relations) {
    _with.addAll(relations);
    return this;
  }

  // ---------------------------------------------------------------------------
  // ORDERING & LIMITS
  // ---------------------------------------------------------------------------

  QueryBuilder<T> orderBy(String column, {String direction = 'ASC'}) {
    _assertIdent(column, dotted: true, what: 'orderBy column');

    final dirUpper = direction.toUpperCase();
    if (dirUpper != 'ASC' && dirUpper != 'DESC') {
      throw InvalidQueryException('Invalid direction for orderBy: $direction');
    }

    _orderBy = '${_grammar.wrap(column)} $dirUpper';
    return this;
  }

  QueryBuilder<T> limit(int limit) {
    _limit = limit;
    return this;
  }

  QueryBuilder<T> offset(int offset) {
    _offset = offset;
    return this;
  }

  // ---------------------------------------------------------------------------
  // INTERNALS
  // ---------------------------------------------------------------------------

  /// Transitions the builder to a new Model type [U] while preserving query constraints.
  ///
  /// Used when query logic (like a generic scope or mixin) needs to operate on a subclass
  /// or a different entity that shares the same table/structure.
  QueryBuilder<U> cast<U extends Model>(
    U Function(Map<String, dynamic>) newCreator, {
    U Function()? instanceFactory,
  }) {
    final qb = QueryBuilder<U>(
      table,
      newCreator,
      instanceFactory: instanceFactory,
    );

    qb._columns = _columns;
    qb._wheres.addAll(_wheres);
    qb._bindings.addAll(_bindings);
    qb._joins.addAll(_joins);
    qb._with.addAll(_with);
    qb._groupBy.addAll(_groupBy);
    qb._havings.addAll(_havings);
    qb._havingBindings.addAll(_havingBindings);
    qb._globalScopes.addAll(_globalScopes);
    qb._ignoreGlobalScopes = _ignoreGlobalScopes;
    qb._orderBy = _orderBy;
    qb._limit = _limit;
    qb._offset = _offset;

    return qb;
  }

  /// Assembles the SQL string.
  ///
  /// Note: [bindings] remain separate to be passed to the driver's prepared statement.
  String _compileSql() {
    return _grammar.compileSelect(this);
  }

  /// Resolves eager loads by delegating to the Model's relation definition.
  ///
  /// Iterates through the result set [models] and matches related records in-memory
  /// or via secondary queries.
  Future<void> _eagerLoad(List<T> models) async {
    if (_with.isEmpty || models.isEmpty) return;

    // Eager load related models parallel
    await Future.wait(
      _with.map((relationName) async {
        final relation = models.first.getRelation(relationName);
        if (relation != null) {
          await relation.match(models, relationName);
        }
      }),
    );
  }

  /// Maps raw DB rows to concrete Model instances.
  ///
  /// Handles lifecycle initialization:
  /// - Sets [exists] to true.
  /// - Takes a snapshot for dirty checking ([syncOriginal]).
  /// - Triggers eager loading.
  Future<List<T>> _hydrate(List<Map<String, dynamic>> rows) async {
    final models = <T>[];

    for (final row in rows) {
      final model = creator(row);
      model.exists = true;
      model.syncOriginal();
      models.add(model);
    }

    await _eagerLoad(models);
    return models;
  }

  Future<T?> first() async {
    final clone = cast<T>(creator, instanceFactory: _instanceFactory);
    clone.limit(1);
    final results = await clone.get();
    return results.isNotEmpty ? results.first : null;
  }

  /// Executes the compiled query and hydrates results.
  Future<List<T>> get() async {
    _applyScopes();
    final dbManager = DatabaseManager();
    final sql = _compileSql();
    final allBindings = _grammar.prepareBindings([..._bindings, ..._havingBindings]);

    try {
      final resultRows = await dbManager.getAll(sql, allBindings);
      return _hydrate(resultRows);
    } catch (e) {
      throw QueryException(
        sql: sql,
        bindings: allBindings,
        message: 'Failed to execute query: ${e.toString()}',
        originalError: e,
      );
    }
  }

  Future<int> update(Map<String, dynamic> values) async {
    _applyScopes();

    if (values.isEmpty) {
      return 0;
    }

    final sql = _grammar.compileUpdate(this, values);
    final allBindings = _grammar.prepareBindings([...values.values, ..._bindings]);

    return await DatabaseManager().execute(sql, allBindings);
  }

  Future<int> delete() async {
    _applyScopes();
    final sql = _grammar.compileDelete(this);
    final bindings = _grammar.prepareBindings(_bindings);

    return await DatabaseManager().execute(sql, bindings);
  }

  /// Executes a raw INSERT into the database.
  ///
  /// WARNING: Bypasses the Model lifecycle (no events, automatic timestamps, or casts).
  /// Returns the ID of the inserted record (if supported by the driver, e.g., autoincrement).
  Future<int> insert(Map<String, dynamic> values) async {
    if (values.isEmpty)
      throw const InvalidQueryException('Insert values cannot be empty');
    values.keys.forEach(
      (k) => _assertIdent(k, dotted: false, what: 'column name'),
    );

    return await DatabaseManager().insert(table, values);
  }

  /// Returns a reactive stream that emits updated results when the table changes.
  ///
  /// Leverages the underlying database adapter's change notifications (e.g., SQLite triggers).
  /// Essential for Flutter reactive UIs (StreamBuilder).
  Stream<List<T>> watch() {
    _applyScopes();
    final db = DatabaseManager().db;
    final sql = _compileSql();
    final allBindings = _grammar.prepareBindings([..._bindings, ..._havingBindings]);

    return db.watch(sql, parameters: allBindings).asyncMap(_hydrate);
  }

  /// Helper for aggregate queries (Count, Sum, etc).
  ///
  /// Modifies the SELECT clause to return a single scalar value.
  Future<T?> _scalar<T>(String expression) async {
    _applyScopes();
    final dbManager = DatabaseManager();

    // Use a temporary modification of columns to compile the scalar query
    final originalColumns = _columns;
    _columns = [RawExpression('$expression as aggregate')];
    
    // We can't just set _columns and call _compileSql because other parts of the grammar 
    // might look at columns, but generally compileSelect uses query.columns.
    // However, to be safe and use the Strategy, we rely on _compileSql which uses Grammar.
    // But wait, _scalar constructs SQL manually in the old version.
    // We should use the grammar.
    
    final sql = _compileSql();
    _columns = originalColumns; // Restore

    final allBindings = _grammar.prepareBindings([..._bindings, ..._havingBindings]);

    try {
      final row = await dbManager.get(sql, allBindings);

      if (row.isEmpty || row['aggregate'] == null) {
        return null;
      }

      final value = row['aggregate'];

      if (T == int && value is num) {
        return value.toInt() as T;
      }
      if (T == double && value is num) {
        return value.toDouble() as T;
      }

      return value as T;
    } catch (e) {
      throw QueryException(
        sql: sql,
        bindings: allBindings,
        message: 'Failed to execute aggregate query: ${e.toString()}',
        originalError: e,
      );
    }
  }
}


--- FILE: lib/src/core/typed_query.dart ---
import 'model.dart';
import 'query_builder.dart';

/// Bridge to obtain a strongly-typed `QueryBuilder<T>` from a Model instance.
extension TypedQuery<T extends Model> on T {
  /// Bootstraps the builder chain.
  ///
  /// Downcasts the base `QueryBuilder<Model>` to `QueryBuilder<T>` to ensure
  /// `get()` returns concrete `List<T>` instead of generic `List<Model>`.
  QueryBuilder<T> query() {
    final base = (this as Model).newQuery();
    return base.cast<T>(
      (map) => fromMap(map) as T,
      instanceFactory: () => (this as Model).newInstance() as T,
    );
  }
}


--- FILE: lib/src/core/model.dart ---
import '../../bavard.dart';
import 'concerns/has_guards_attributes.dart';
import './concerns/has_casts.dart';
import './concerns/has_events.dart';
import './concerns/has_relationships.dart';
import './concerns/has_attribute_helpers.dart';

/// Core Active Record implementation serving as the bridge between Dart objects and the DB.
///
/// Aggregates feature mixins (Events, Casts, Relations) and manages the
/// persistence lifecycle, including dirty checking and attribute synchronization.
/// Concrete classes need only define the [table] and the [fromMap] hydration factory.
abstract class Model
    with
        HasCasts,
        HasEvents,
        HasRelationships,
        HasAttributeHelpers,
        HasGuardsAttributes {
  Model newInstance() => fromMap(const {});

  @override
  String get table;

  @override
  String get primaryKey => 'id';

  /// The raw data source for the model. Modified by setters/casts, read by getters/DB.
  @override
  Map<String, dynamic> attributes;

  @override
  dynamic get id => attributes[primaryKey];

  set id(dynamic value) => attributes[primaryKey] = value;

  Model([Map<String, dynamic> attributes = const {}])
    : attributes = Map<String, dynamic>.from(attributes);

  /// Indicates if the model currently exists in the database (persisted).
  /// This change logic for CREATE or UPDATE
  bool exists = false;

  /// A snapshot of attributes at the time of hydration or last save.
  /// Used to calculate diffs for efficient UPDATE queries.
  Map<String, dynamic> original = {};

  void registerGlobalScopes(QueryBuilder<Model> builder) {}

  dynamic _deepCopy(dynamic value) {
    if (value is Map) {
      return value.map<String, dynamic>(
        (k, v) => MapEntry(k.toString(), _deepCopy(v)),
      );
    } else if (value is List) {
      return value.map((v) => _deepCopy(v)).toList();
    } else if (value is Set) {
      return value.map((v) => _deepCopy(v)).toSet();
    }

    return value;
  }

  /// Snapshots current attributes to [original].
  ///
  /// Critical for "Dirty Checking" to ensure only changed fields are sent to the DB.
  void syncOriginal() {
    original = _deepCopy(attributes) as Map<String, dynamic>;
  }

  /// Container for eager-loaded data (e.g., `user.relations['posts']`).
  @override
  Map<String, dynamic> relations = {};

  /// Factory method to hydrate a concrete instance from a DB row (Map).
  Model fromMap(Map<String, dynamic> map);

  /// Entry point for the Fluent Query Builder.
  ///
  /// Binds the [fromMap] factory to the builder to ensure results are hydrated
  /// into concrete Model instances rather than raw Maps.
  QueryBuilder<Model> newQuery() {
    final builder = QueryBuilder(
      table,
      fromMap,
      instanceFactory: () => newInstance(),
    );
    registerGlobalScopes(builder);
    return builder;
  }

  QueryBuilder<Model> where(String column, dynamic value) =>
      newQuery().where(column, value);

  QueryBuilder<Model> withRelations(List<String> rels) =>
      newQuery().withRelations(rels);

  /// Persists the model to storage (Upsert logic).
  ///
  /// Flow:
  /// 1. Trigger [onSaving].
  /// 2. If new ([exists] is false): perform INSERT.
  /// 3. If existing: Calculate diff ([dirtyAttributes]) and UPDATE only changed fields.
  /// 4. Refresh: Re-fetch record to sync DB-generated values (autoincrement IDs, timestamps, triggers).
  /// 5. Trigger [onSaved].
  Future<void> save() async {
    if (!await onSaving()) return;

    final dbManager = DatabaseManager();

    if (!exists) {
      final insertId = await dbManager.insert(table, attributes);
      id ??= insertId;
      exists = true;
    } else {
      // Dirty Checking: identify strictly changed values to optimize the SQL payload.
      final dirtyAttributes = <String, dynamic>{};
      attributes.forEach((key, value) {
        if (key != primaryKey && value != original[key]) {
          dirtyAttributes[key] = value;
        }
      });

      if (dirtyAttributes.isEmpty) {
        return;
      }

      await query().where(primaryKey, id).update(dirtyAttributes);
    }
    await refresh();
    await onSaved();
  }

  Future<void> refresh() async {
    if (id == null) return;
    // Reset with withoutGlobalScopes to avoid eager-loading issues
    final freshInstance = await newQuery().withoutGlobalScopes().findOrFail(id);
    attributes = freshInstance.attributes;
    syncOriginal();
  }

  /// Permanently removes the record (unless [HasSoftDeletes] overrides this).
  ///
  /// Triggers [onDeleting] (can cancel) and [onDeleted] hooks.
  Future<void> delete() async {
    if (id != null && await onDeleting()) {
      await newQuery().where(primaryKey, id).delete();
      await onDeleted();
    }
  }
}

/// Helper extension to safely cast dynamic relation data.
extension TypedRelations on Model {
  /// Safely retrieves a single related model (1:1 or N:1).
  T? getRelated<T>(String name) {
    if (!relations.containsKey(name)) return null;
    return relations[name] as T?;
  }

  /// Safely retrieves a list of related models (1:N or N:N).
  List<T> getRelationList<T>(String name) {
    if (!relations.containsKey(name)) return [];

    final list = relations[name];
    if (list is List) {
      return list.cast<T>();
    }

    return [];
  }
}


--- FILE: lib/src/test/mock_database.dart ---
import 'dart:async';
import 'package:bavard/bavard.dart';

/// A test double for [DatabaseAdapter] that records query history and allows
/// configuring responses based on SQL substrings.
///
/// Use this to verify that your repository layer generates the expected SQL
/// and correctly handles transaction lifecycles without a real database.
class MockDatabaseSpy implements DatabaseAdapter {
  /// The last executed SQL statement, exposed for test assertions.
  String lastSql = '';
  List<dynamic>? lastArgs;

  /// Full log of all executed SQL statements in chronological order.
  List<String> history = [];

  final List<Map<String, dynamic>> _defaultData;
  Map<String, List<Map<String, dynamic>>> _smartResponses;

  bool _inTransaction = false;
  
  // Default grammar for testing
  final Grammar _grammar = SQLiteGrammar();

  @override
  Grammar get grammar => _grammar;

  /// Captures SQL statements executed specifically within the current transaction scope.
  List<String> transactionHistory = [];

  /// If true, operations within a transaction will throw an exception
  /// to simulate database failures and test rollback logic.
  bool shouldFailTransaction = false;

  /// Creates the spy with optional [defaultData] for unmatched queries and
  /// [smartResponses] mapped by SQL substrings.
  MockDatabaseSpy([
    this._defaultData = const [],
    Map<String, List<Map<String, dynamic>>> smartResponses = const {},
  ]) : _smartResponses = Map.from(smartResponses);

  /// Updates the mock response configuration at runtime.
  void setMockData(Map<String, List<Map<String, dynamic>>> data) {
    _smartResponses.clear();
    _smartResponses.addAll(data);
  }

  String _normalize(String sql) => sql.replaceAll('"', '');

  /// Logs the query and returns pre-configured data if [sql] contains a key
  /// defined in [_smartResponses]; otherwise returns [_defaultData].
  @override
  Future<List<Map<String, dynamic>>> getAll(
    String sql, [
    List<dynamic>? arguments,
  ]) async {
    lastSql = sql;
    lastArgs = arguments;
    history.add(sql);

    if (_inTransaction) {
      transactionHistory.add(sql);
    }

    // Simple substring matching to find the correct mock response.
    // Check raw SQL first
    for (var key in _smartResponses.keys) {
      if (sql.contains(key)) {
        return _smartResponses[key]!;
      }
    }
    
    // Check normalized (unquoted) SQL for backward compatibility with tests
    final normalized = _normalize(sql);
    for (var key in _smartResponses.keys) {
      if (normalized.contains(key)) {
        return _smartResponses[key]!;
      }
    }

    return _defaultData;
  }

  @override
  Future<Map<String, dynamic>> get(
    String sql, [
    List<dynamic>? arguments,
  ]) async {
    final results = await getAll(sql, arguments);
    return results.isNotEmpty ? results.first : {};
  }

  @override
  Future<int> execute(String sql, [List<dynamic>? arguments]) async {
    lastSql = sql;
    lastArgs = arguments;
    history.add(sql);

    if (_inTransaction) {
      transactionHistory.add(sql);

      if (shouldFailTransaction) {
        throw Exception('Simulated transaction failure');
      }

      return 1;
    }
    return 1;
  }

  /// Returns a static stream of [_defaultData].
  ///
  /// Does not simulate actual database updates or reactive stream behavior.
  @override
  Stream<List<Map<String, dynamic>>> watch(
    String sql, {
    List<dynamic>? parameters,
  }) {
    return Stream.value(_defaultData);
  }

  @override
  Future<dynamic> insert(String table, Map<String, dynamic> values) async {
    // Manually reconstructs the SQL string to ensure the repository logic
    // produced the correct keys and structure for logging purposes.
    final keys = values.keys.join(', ');
    final placeholders = List.filled(values.length, '?').join(', ');
    final sql = 'INSERT INTO $table ($keys) VALUES ($placeholders)';

    lastSql = sql;
    lastArgs = values.values.toList();
    history.add(sql);

    if (_inTransaction) {
      transactionHistory.add(sql);

      if (shouldFailTransaction) {
        throw Exception('Simulated transaction failure');
      }
    }

    // Check if a specific ID return is mocked, otherwise default to 1.
    if (_smartResponses.containsKey('last_insert_row_id')) {
      final row = _smartResponses['last_insert_row_id']!.first;
      return row['id'] ?? 1;
    }

    return 1;
  }

  @override
  bool get supportsTransactions => true;

  /// Executes a transaction scope.
  ///
  /// Manages `_inTransaction` state and logs lifecycle events (`BEGIN`, `COMMIT`, `ROLLBACK`)
  /// to [history] to verify transaction boundaries.
  @override
  Future<T> transaction<T>(
    Future<T> Function(TransactionContext txn) callback,
  ) async {
    _inTransaction = true;
    transactionHistory.clear();
    history.add('BEGIN TRANSACTION');

    try {
      final context = MockTransactionContext(this);
      final result = await callback(context);

      history.add('COMMIT');
      _inTransaction = false;
      return result;
    } catch (e) {
      history.add('ROLLBACK');
      _inTransaction = false;
      rethrow;
    }
  }
}

/// A pass-through wrapper ensuring that operations inside a transaction block
/// are routed back to the main [MockDatabaseSpy] instance.
class MockTransactionContext implements TransactionContext {
  final MockDatabaseSpy _db;

  MockTransactionContext(this._db);

  @override
  Future<List<Map<String, dynamic>>> getAll(
    String sql, [
    List<dynamic>? arguments,
  ]) {
    return _db.getAll(sql, arguments);
  }

  @override
  Future<Map<String, dynamic>> get(String sql, [List<dynamic>? arguments]) {
    return _db.get(sql, arguments);
  }

  @override
  Future<int> execute(String sql, [List<dynamic>? arguments]) {
    return _db.execute(sql, arguments);
  }

  @override
  Future<dynamic> insert(String table, Map<String, dynamic> values) {
    return _db.insert(table, values);
  }
}


--- FILE: lib/src/relations/has_one.dart ---
import 'has_many.dart';
import '../core/model.dart';

/// Defines a one-to-one relationship where the foreign key resides on the related model [R].
///
/// Inherits from [HasMany] to reuse query construction and batch fetching logic,
/// effectively treating the relation as a "collection of one" at the database level.
class HasOne<R extends Model> extends HasMany<R> {
  HasOne(super.parent, super.creator, super.foreignKey, super.localKey);

  Future<R?> getResult() => first();

  /// Eagerly loads the relationship by leveraging [HasMany.match] for batch fetching,
  /// then unwraps the resulting list into a single instance (or null).
  @override
  Future<void> match(List<Model> models, String relationName) async {
    // Reuse HasMany to fetch and group data into lists.
    await super.match(models, relationName);

    for (var model in models) {
      final list = model.relations[relationName] as List?;
      model.relations[relationName] = (list != null && list.isNotEmpty)
          ? list.first
          : null;
    }
  }
}


--- FILE: lib/src/relations/has_many_through.dart ---
import 'relation.dart';
import '../core/utils.dart';
import '../core/model.dart';

/// Defines a distant one-to-many relationship linking a Parent to a Target via an Intermediate model.
///
/// e.g. A `Country` has many `Post`s through `User`:
/// Country (Parent) -> User (Intermediate, holds `country_id`) -> Post (Target, holds `user_id`).
class HasManyThrough<R extends Model, I extends Model> extends Relation<R> {
  final I Function(Map<String, dynamic>) intermediateCreator;

  /// Foreign key on the Intermediate table pointing to the Parent.
  final String? firstKey;

  /// Foreign key on the Target table pointing to the Intermediate model.
  final String? secondKey;

  HasManyThrough(
    super.parent,
    super.creator,
    this.intermediateCreator,
    this.firstKey,
    this.secondKey,
  ) {
    addConstraints();
  }

  // --- Internal Helpers for Key Resolution ---

  String get _intermediateTable => intermediateCreator({}).table;

  /// Resolves the foreign key pointing to Parent, defaulting to snake_case convention if null.
  String get _firstKey => firstKey ?? Utils.foreignKey(parent.table);

  /// Resolves the foreign key pointing to Intermediate, defaulting to snake_case convention if null.
  String get _secondKey => secondKey ?? Utils.foreignKey(_intermediateTable);

  /// Configures the query for a single parent instance.
  ///
  /// Performs an INNER JOIN between the Target and Intermediate tables (`target.second_key = intermediate.id`)
  /// so that results can be filtered by the Parent's ID (`intermediate.first_key = parent.id`).
  @override
  void addConstraints() {
    join(
      _intermediateTable,
      '$_intermediateTable.id',
      '=',
      '$table.$_secondKey',
    );
    where('$_intermediateTable.$_firstKey', parent.id);
  }

  /// Eagerly loads relationships for a list of parents to avoid N+1 queries.
  ///
  @override
  Future<void> match(List<Model> models, String relationName) async {
    final parentIds = getKeys(models, parent.primaryKey);

    final intermediateResults = await intermediateCreator(
      {},
    ).newQuery().select(['id', _firstKey]).whereIn(_firstKey, parentIds).get();

    final intermediateMap = {
      for (var r in intermediateResults)
        normKey(r.id): normKey(r.attributes[_firstKey]),
    };

    final intermediateIds = intermediateMap.keys.whereType<String>().toList();
    if (intermediateIds.isEmpty) return;

    final targets = (await creator(
      {},
    ).newQuery().whereIn(_secondKey, intermediateIds).get()).cast<R>();

    for (var model in models) {
      final myParentId = normKey(model.id);

      final relevantIntermediateIds = intermediateMap.entries
          .where((e) => e.value == myParentId)
          .map((e) => e.key)
          .toSet();

      model.relations[relationName] = targets
          .where(
            (t) => relevantIntermediateIds.contains(
              normKey(t.attributes[_secondKey]),
            ),
          )
          .toList();
    }
  }
}


--- FILE: lib/src/relations/morph_to.dart ---
import 'relation.dart';
import '../core/model.dart';

/// Represents the inverse side of a polymorphic relationship (the child holding the keys).
///
/// Unlike standard relations, the target Model and Table are not fixed; they are resolved
/// dynamically at runtime based on the `{name}_type` and `{name}_id` columns.
class MorphTo<R extends Model> extends Relation<R> {
  final String name;

  /// Maps the discriminator string (stored in `{name}_type`) to the corresponding Model factory.
  /// Essential for knowing which table to query for a given record.
  final Map<String, R Function(Map<String, dynamic>)> typeMap;

  // Passes a dummy `_MorphModel` to the super constructor because the actual target table
  // is unknown at instantiation time. Real queries use `typeMap` factories.
  MorphTo(Model parent, this.name, this.typeMap)
    : super(parent, (_) => _MorphModel() as R);

  /// No-op: Standard SQL constraints cannot be applied globally here because
  /// the target table varies from record to record.
  @override
  void addConstraints() {
    // Dynamic resolution happens in [getResult] or [match].
  }

  /// Lazy-loads the parent for the current instance.
  ///
  /// Resolves the specific table via [typeMap] using the stored `{name}_type`.
  /// Returns `null` if the discriminator is missing or not mapped.
  Future<R?> getResult() async {
    final type = parent.attributes['${name}_type']?.toString();
    final id = parent.attributes['${name}_id'];

    if (type == null || id == null) return null;

    final creator = typeMap[type];
    if (creator == null) return null;

    final dummy = creator(const {});

    return dummy
        .newQuery()
        .where(dummy.primaryKey, id)
        .first()
        .then((value) => value as R?);
  }

  @override
  Future<R?> first() => getResult();

  /// Throws [UnsupportedError].
  ///
  /// A standard `get()` is impossible because a single query cannot target multiple
  /// unknown tables simultaneously. Use `getResult()` or eager loading (`withRelations`).
  @override
  Future<List<R>> get() {
    throw UnsupportedError(
      'MorphTo does not support get() because the target table is dynamic. '
      'Use getResult() / first() or eager load via withRelations().',
    );
  }

  @override
  Stream<List<R>> watch() {
    throw UnsupportedError(
      'MorphTo does not support watch() because the target table is dynamic.',
    );
  }

  /// Eagerly loads parents for a list of mixed-type children.
  ///
  /// Optimization Strategy:
  /// 1. Buckets child IDs by their polymorphic `type` (e.g., separates 'posts' from 'videos').
  /// 2. Executes exactly one query per distinct type found.
  /// 3. Merges results into a lookup dictionary to populate relations in memory.
  @override
  Future<void> match(List<Model> models, String relationName) async {
    Map<String, List<dynamic>> mapByType = {};

    // 1. Group IDs by type
    for (var model in models) {
      final type = model.attributes['${name}_type']?.toString();
      final id = model.attributes['${name}_id'];

      if (type != null && id != null) {
        mapByType.putIfAbsent(type, () => []);
        mapByType[type]!.add(id);
      }
    }

    Map<String, Map<String, Model>> resultsByType = {};

    // 2. Query each type individually
    for (var type in mapByType.keys) {
      final creator = typeMap[type];
      if (creator == null) continue;

      final ids = mapByType[type]!;
      final dummyModel = creator(const {});

      final results = await dummyModel
          .newQuery()
          .whereIn(dummyModel.primaryKey, ids)
          .get();

      resultsByType[type] = {for (var r in results) normKey(r.id)!: r};
    }

    // 3. Assign results back to children
    for (var model in models) {
      final type = model.attributes['${name}_type']?.toString();
      final id = normKey(model.attributes['${name}_id']);

      if (type == null || id == null) continue;

      final dict = resultsByType[type];
      if (dict != null && dict.containsKey(id)) {
        model.relations[relationName] = dict[id];
      }
    }
  }
}

/// Internal sentinel used to satisfy type constraints during [MorphTo] initialization.
/// Prevents runtime crashes when the Relation constructor demands a table name.
class _MorphModel extends Model {
  @override
  String get table => '_morph';

  _MorphModel([super.attributes]);

  @override
  _MorphModel fromMap(Map<String, dynamic> map) => _MorphModel(map);
}


--- FILE: lib/src/relations/morph_many.dart ---
import 'relation.dart';
import '../core/model.dart';

/// Defines a polymorphic one-to-many relationship.
///
/// Allows a child model to belong to multiple types of parent models using a composite key
/// (ID + Type), rather than specific foreign keys.
/// e.g. A `Comment` belongs to either a `Post` or `Video` via `commentable_id` and `commentable_type`.
class MorphMany<R extends Model> extends Relation<R> {
  /// The prefix for the polymorphic columns (e.g., "commentable" implies `commentable_id` and `commentable_type`).
  final String name;

  /// The discriminator value stored in the `{name}_type` column (defaults to the parent's table name).
  final String type;

  final String id;

  MorphMany(super.parent, super.creator, this.name)
    : type = parent.table,
      id = parent.id.toString() {
    addConstraints();
  }

  /// Filters by both the discriminator type and the foreign ID.
  ///
  /// Both constraints are required because foreign IDs are not unique across different parent tables.
  @override
  void addConstraints() {
    where('${name}_type', type);
    where('${name}_id', id);
  }

  /// Eagerly loads polymorphic children for a list of parents.
  ///
  /// Queries the child table for records matching the specific parent [type]
  /// and the list of parent IDs, then distributes them in-memory.
  @override
  Future<void> match(List<Model> models, String relationName) async {
    final ids = getKeys(models, parent.primaryKey);

    final results =
        (await creator({})
                .newQuery()
                .where('${name}_type', type)
                .whereIn('${name}_id', ids)
                .get())
            .cast<R>();

    for (var model in models) {
      final myId = normKey(model.id);

      model.relations[relationName] = results
          .where(
            (r) =>
                normKey(r.attributes['${name}_id']) == myId &&
                r.attributes['${name}_type'] == type,
          )
          .toList();
    }
  }
}


--- FILE: lib/src/relations/belongs_to.dart ---
import 'relation.dart';
import '../core/model.dart';

/// Defines an inverse one-to-one or many-to-one relationship where the foreign key
/// resides on the child model (the [parent] of this relation instance).
///
/// e.g. A `Comment` belongs to a `Post` (Comment has `post_id`).
class BelongsTo<R extends Model> extends Relation<R> {
  final String foreignKey;
  final String ownerKey;

  BelongsTo(super.parent, super.creator, this.foreignKey, this.ownerKey) {
    addConstraints();
  }

  /// Applies constraints for lazy loading: filters the query where the
  /// [ownerKey] matches the current model's [foreignKey].
  @override
  void addConstraints() {
    where(ownerKey, parent.attributes[foreignKey]);
  }

  Future<R?> getResult() => first();

  /// Eagerly loads related models in a single batch query to prevent N+1 performance issues.
  ///
  /// Matches the fetched owners back to the [models] list via an in-memory dictionary lookup.
  @override
  Future<void> match(List<Model> models, String relationName) async {
    final ids = getKeys(models, foreignKey).where((id) => id != null).toList();

    final results = await creator({}).newQuery().whereIn(ownerKey, ids).get();

    // Map results by owner ID for O(1) assignment back to child models.
    final dictionary = {
      for (var r in results) normKey(r.attributes[ownerKey]): r,
    };

    for (var model in models) {
      final key = normKey(model.attributes[foreignKey]);
      if (key != null && dictionary.containsKey(key)) {
        model.relations[relationName] = dictionary[key];
      }
    }
  }
}


--- FILE: lib/src/relations/has_many.dart ---
import 'relation.dart';
import '../core/model.dart';

/// Defines a one-to-many relationship where the foreign key resides on the related model [R].
///
/// e.g. A `User` has many `Post`s (the `posts` table contains a `user_id` column).
class HasMany<R extends Model> extends Relation<R> {
  /// The column on the related model [R] that references the parent.
  final String foreignKey;

  /// The column on the current parent model acting as the reference (usually 'id').
  final String localKey;

  HasMany(super.parent, super.creator, this.foreignKey, this.localKey) {
    addConstraints();
  }

  /// Filters the query to return only children belonging to the current parent instance.
  @override
  void addConstraints() {
    where(foreignKey, parent.attributes[localKey]);
  }

  Future<R> create(Map<String, dynamic> values) async {
    values[foreignKey] = parent.attributes[localKey];

    final instance = creator(values);
    await instance.save();
    return instance;
  }

  /// Eagerly loads related models for a list of parents to prevent N+1 performance issues.
  ///
  /// Fetches all related children in a single `WHERE IN` query and distributes them
  /// to the corresponding parents in-memory.
  @override
  Future<void> match(List<Model> models, String relationName) async {
    final ids = getKeys(models, localKey);

    final results = (await creator(
      {},
    ).newQuery().whereIn(foreignKey, ids).get()).cast<R>();

    for (var model in models) {
      final myKey = normKey(model.attributes[localKey]);
      // Filters the fetched results to find children belonging to this specific parent.
      final children = results
          .where((r) => normKey(r.attributes[foreignKey]) == myKey)
          .toList();

      model.relations[relationName] = children;
    }
  }
}


--- FILE: lib/src/relations/morph_to_many.dart ---
import 'relation.dart';
import '../core/model.dart';
import '../core/database_manager.dart';
import '../core/utils.dart';

/// Defines a polymorphic many-to-many relationship.
///
/// Allows a model to belong to multiple other models of different types via a single pivot table
/// that tracks both ID and Type (e.g., a `Tag` system used by both `Post` and `Video`).
///
/// Schema convention (e.g. name='taggable'):
/// - Pivot table: `taggables`
/// - Columns: `tag_id` (Related), `taggable_id` (Parent ID), `taggable_type` (Parent Table).
class MorphToMany<R extends Model> extends Relation<R> {
  final String name;

  MorphToMany(super.parent, super.creator, this.name) {
    addConstraints();
  }

  // --- Convention-based Pivot Configuration ---

  String get pivotTable => '${name}s';

  /// Column referencing the related model (e.g., `tag_id`).
  String get pivotRelatedId => Utils.foreignKey(table);

  /// Column storing the parent's ID (e.g., `taggable_id`).
  String get pivotMorphId => '${name}_id';

  /// Column storing the parent's discriminator type (e.g., `taggable_type`).
  String get pivotMorphType => '${name}_type';

  /// Configures the INNER JOIN and filters by both Parent ID and Parent Type.
  ///
  /// The type check (`pivotMorphType`) is strictly required to differentiate between
  /// parents from different tables that might share the same numeric ID.
  @override
  void addConstraints() {
    join(pivotTable, '$table.id', '=', '$pivotTable.$pivotRelatedId');
    where('$pivotTable.$pivotMorphId', parent.id);
    where('$pivotTable.$pivotMorphType', parent.table);
  }

  /// Eagerly loads relationships to solve N+1 performance issues.
  ///
  /// Strategy:
  /// 1. Query the pivot table directly using raw SQL to filter by the specific parent Type
  ///    and the list of Parent IDs.
  /// 2. Batch fetch the related models using the IDs extracted from the pivot results.
  /// 3. Reconstruct the many-to-many mappings in-memory.
  @override
  Future<void> match(List<Model> models, String relationName) async {
    final parentIds = getKeys(models, parent.primaryKey);
    final db = DatabaseManager().db;

    final relatedForeignKey = Utils.foreignKey(table);

    // Raw SQL required to combine static Type filtering with dynamic ID IN-clause.
    final pivotSql =
        "SELECT * FROM $pivotTable WHERE $pivotMorphType = ? AND ${name}_id IN (${parentIds.map((_) => '?').join(',')})";

    final params = [parent.table, ...parentIds];
    final pivotRows = await db.getAll(pivotSql, params);

    if (pivotRows.isEmpty) return;

    final relatedIds = pivotRows
        .map((r) => r[relatedForeignKey])
        .toSet()
        .toList();

    // Dynamically resolve the primary key of the related model (do not assume 'id').
    final relatedPk = creator({}).primaryKey;

    final relatedModels = (await creator(
      {},
    ).newQuery().whereIn(relatedPk, relatedIds).get()).cast<R>();

    // Map: related_id -> model instance
    final relatedDict = {for (var m in relatedModels) normKey(m.id)!: m};

    for (var model in models) {
      final myId = normKey(model.id);

      final myPivots = pivotRows.where(
        (r) =>
            normKey(r[pivotMorphId]) == myId &&
            r[pivotMorphType] == parent.table,
      );

      final list = <R>[];
      for (var pivot in myPivots) {
        final rId = normKey(pivot[relatedForeignKey]);
        if (rId != null && relatedDict.containsKey(rId)) {
          list.add(relatedDict[rId]!);
        }
      }

      model.relations[relationName] = list;
    }
  }
}


--- FILE: lib/src/relations/belongs_to_many.dart ---
import 'relation.dart';
import '../core/model.dart';
import '../core/database_manager.dart';

/// Manages many-to-many relationships via an intermediate pivot table.
///
/// Requires [foreignPivotKey] (points to current parent) and [relatedPivotKey]
/// (points to related model [R]) on the [pivotTable].
class BelongsToMany<R extends Model> extends Relation<R> {
  final String pivotTable;
  final String foreignPivotKey;
  final String relatedPivotKey;

  BelongsToMany(
    super.parent,
    super.creator,
    this.pivotTable,
    this.foreignPivotKey,
    this.relatedPivotKey,
  ) {
    addConstraints();
  }

  /// Configures the INNER JOIN between the related table and pivot table,
  /// filtering results to match the current parent's ID.
  @override
  void addConstraints() {
    final relatedTable = table;
    // Instantiate dummy model to resolve the primary key name dynamically.
    final relatedKey = creator({}).primaryKey;

    join(
      pivotTable,
      '$relatedTable.$relatedKey',
      '=',
      '$pivotTable.$relatedPivotKey',
    );

    where('$pivotTable.$foreignPivotKey', parent.id);
  }

  /// Eagerly loads relationships to solve N+1 issues.
  ///
  /// Strategy:
  /// 1. Fetch pivot rows via raw SQL (bypassing QueryBuilder for the intermediate table).
  /// 2. Fetch related models in a single batch.
  /// 3. Stitch results back to parents in-memory.
  @override
  Future<void> match(List<Model> models, String relationName) async {
    final parentIds = getKeys(models, parent.primaryKey);
    if (parentIds.isEmpty) return;

    final db = DatabaseManager().db;

    final placeholders = List.filled(parentIds.length, '?').join(',');
    final pivotSql =
        'SELECT * FROM $pivotTable WHERE $foreignPivotKey IN ($placeholders)';
    final pivotRows = await db.getAll(pivotSql, parentIds);

    if (pivotRows.isEmpty) return;

    final relatedIds = pivotRows
        .map((r) => r[relatedPivotKey])
        .toSet()
        .toList();

    final pk = creator({}).primaryKey;
    final relatedModels = (await creator(
      {},
    ).newQuery().whereIn(pk, relatedIds).get()).cast<R>();

    // Map for O(1) lookup: related_id -> model instance
    final relatedDict = {for (var m in relatedModels) normKey(m.id)!: m};

    for (var model in models) {
      final myId = normKey(model.id);

      // Filter pivots belonging to this specific parent
      final myPivots = pivotRows.where(
        (r) => normKey(r[foreignPivotKey]) == myId,
      );

      final matches = <R>[];
      for (var pivot in myPivots) {
        final rId = normKey(pivot[relatedPivotKey]);
        if (rId != null && relatedDict.containsKey(rId)) {
          matches.add(relatedDict[rId]!);
        }
      }

      model.relations[relationName] = matches;
    }
  }
}


--- FILE: lib/src/relations/relation.dart ---
import '../core/model.dart';
import '../core/query_builder.dart';

/// Base class for all database relationships.
///
/// Extends [QueryBuilder] to allow fluent chaining of additional constraints
/// directly on the relationship (e.g., `user.posts().where('active', 1).get()`).
abstract class Relation<R extends Model> extends QueryBuilder<R> {
  /// The model instance that spawned this relationship query.
  final Model parent;

  Relation(this.parent, R Function(Map<String, dynamic>) creator)
    : super(
        creator(const {}).table,
        creator,
        instanceFactory: () => creator(const {}).newInstance() as R,
      ) {
    final instance = creator(const {});
    instance.registerGlobalScopes(this);
  }

  /// Applies the initial SQL filtering (e.g., `WHERE user_id = ?`) to scope
  /// the query to the current [parent].
  void addConstraints();

  /// Eager loading contract: fetches related records for a batch of [models]
  /// in a single query (solving N+1) and injects them into the `relations` map.
  Future<void> match(List<Model> models, String relationName);

  /// Extracts unique attribute values from a list of models, used to build
  /// `WHERE IN` clauses for batch fetching.
  List<dynamic> getKeys(List<Model> models, String key) {
    return models.map((m) => m.attributes[key]).toSet().toList();
  }

  /// Normalizes keys to Strings to prevent map lookup failures caused by
  /// Type mismatches (e.g. `int` vs `String`) during result matching.
  String? normKey(dynamic v) => v?.toString();
}


--- FILE: lib/src/relations/morph_one.dart ---
import 'morph_many.dart';
import '../core/model.dart';

/// Defines a polymorphic one-to-one relationship.
///
/// Structurally identical to [MorphMany] (uses composite ID+Type keys) but logically
/// restricts the result to a single model instance.
class MorphOne<R extends Model> extends MorphMany<R> {
  MorphOne(super.parent, super.creator, super.name);

  /// Eagerly loads the relationship by delegating batch fetching to [MorphMany.match],
  /// then unwraps the resulting list into a single instance (or null).
  @override
  Future<void> match(List<Model> models, String relationName) async {
    // Reuse MorphMany to fetch and group data into lists efficiently.
    await super.match(models, relationName);

    for (var model in models) {
      final list = model.relations[relationName] as List?;
      model.relations[relationName] = (list != null && list.isNotEmpty)
          ? list.first
          : null;
    }
  }
}


--- FILE: lib/src/grammars/sqlite_grammar.dart ---
import '../core/grammar.dart';
import '../core/query_builder.dart';

class SQLiteGrammar extends Grammar {
  @override
  String compileSelect(QueryBuilder query) {
    return concatenate(compileComponents(query));
  }

  @override
  String compileInsert(QueryBuilder query, Map<String, dynamic> values) {
    final columns = wrapArray(values.keys.toList()).join(', ');
    final placeholders = List.filled(values.length, '?').join(', ');
    return 'INSERT INTO ${wrap(query.table)} ($columns) VALUES ($placeholders)';
  }

  @override
  String compileUpdate(QueryBuilder query, Map<String, dynamic> values) {
    final columns = values.keys.map((key) => '${wrap(key)} = ?').join(', ');
    final where = compileWheres(query);
    return 'UPDATE ${wrap(query.table)} SET $columns $where'.trim();
  }

  @override
  String compileDelete(QueryBuilder query) {
    final where = compileWheres(query);
    return 'DELETE FROM ${wrap(query.table)} $where'.trim();
  }

  @override
  String wrap(String value) {
    if (value == '*') return value;
    if (value.contains('.')) {
      return value.split('.').map((segment) => wrap(segment)).join('.');
    }
    // Don't wrap if already wrapped
    if (value.startsWith('"') && value.endsWith('"')) return value;
    return '"$value"';
  }

  @override
  String parameter(dynamic value) {
    return '?';
  }

  @override
  List<dynamic> prepareBindings(List<dynamic> bindings) {
    return bindings.map((value) {
      if (value is bool) return value ? 1 : 0;
      if (value is DateTime) return value.toIso8601String();
      return value;
    }).toList();
  }
}


--- FILE: lib/src/grammars/postgres_grammar.dart ---
import '../core/grammar.dart';
import '../core/query_builder.dart';

class PostgresGrammar extends Grammar {
  @override
  String compileSelect(QueryBuilder query) {
    return concatenate(compileComponents(query));
  }

  @override
  String compileInsert(QueryBuilder query, Map<String, dynamic> values) {
    final columns = wrapArray(values.keys.toList()).join(', ');
    final placeholders = List.filled(values.length, '?').join(', ');
    return 'INSERT INTO ${wrap(query.table)} ($columns) VALUES ($placeholders) RETURNING id';
  }

  @override
  String compileUpdate(QueryBuilder query, Map<String, dynamic> values) {
    final columns = values.keys.map((key) => '${wrap(key)} = ?').join(', ');
    final where = compileWheres(query);
    return 'UPDATE ${wrap(query.table)} SET $columns $where'.trim();
  }

  @override
  String compileDelete(QueryBuilder query) {
    final where = compileWheres(query);
    return 'DELETE FROM ${wrap(query.table)} $where'.trim();
  }

  @override
  String wrap(String value) {
    if (value == '*') return value;
    if (value.contains('.')) {
      return value.split('.').map((segment) => wrap(segment)).join('.');
    }
    // Don't wrap if already wrapped
    if (value.startsWith('"') && value.endsWith('"')) return value;
    return '"$value"';
  }

  @override
  String parameter(dynamic value) {
    // Note: Parameter binding for Postgres ($1, $2...) is typically handled 
    // by the driver (e.g. 'postgres' package) or needs stateful compilation.
    // For this implementation, we rely on the driver transforming ? or @ 
    // or we return '?' and let the adapter handle substitution if needed.
    // Standard SQL uses '?' or named parameters. 
    // If strict $1 is needed during string generation, this method would 
    // need a counter. For now, we assume the underlying driver or a 
    // post-processing step handles ? -> $i conversion if the driver doesn't support ?.
    return '?';
  }

  @override
  List<dynamic> prepareBindings(List<dynamic> bindings) {
    return bindings.map((value) {
      // Postgres handles boolean natively, no need to convert to 0/1
      if (value is DateTime) return value.toIso8601String();
      return value;
    }).toList();
  }
}


--- FILE: lib/src/schema/columns.dart ---
/// Represents a single query predicate (e.g., "age > 18").
/// Used to build the WHERE clause of a database query.
class WhereCondition {
  final String column;
  final String operator;
  final dynamic value;
  final String boolean;

  const WhereCondition(this.column, this.operator, this.value, {this.boolean = 'AND'});
}

/// Abstract definition of a database schema column.
/// [T] is the Dart type associated with the column's value.
abstract class Column<T> {
  final String? name;
  final bool isNullable;

  /// Prevents this column from being mass-assigned during inserts/updates.
  final bool isGuarded;

  const Column(this.name, {this.isNullable = false, this.isGuarded = false});

  /// The underlying SQL data type definition.
  String get schemaType;

  /// Returns the raw column name or expression used in query generation.
  @override
  String toString() => name ?? '';

  WhereCondition equals(T value) =>
      WhereCondition(toString(), '=', value);

  WhereCondition notEquals(T value) =>
      WhereCondition(toString(), '!=', value);

  WhereCondition isNull() =>
      WhereCondition(toString(), 'IS', null);

  WhereCondition isNotNull() =>
      WhereCondition(toString(), 'IS NOT', null);

  WhereCondition inList(List<T> values) =>
      WhereCondition(toString(), 'IN', values);

  WhereCondition notInList(List<T> values) =>
      WhereCondition(toString(), 'NOT IN', values);
}

/// Maps a Dart [String] to a database TEXT/VARCHAR column.
class TextColumn extends Column<String> {
  const TextColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'string';

  WhereCondition contains(String value) =>
      WhereCondition(name!, 'LIKE', '%$value%');

  WhereCondition startsWith(String value) =>
      WhereCondition(name!, 'LIKE', '$value%');

  WhereCondition endsWith(String value) =>
      WhereCondition(name!, 'LIKE', '%$value');
}

class IntColumn extends Column<int> {
  const IntColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'integer';

  WhereCondition greaterThan(int value) =>
      WhereCondition(name!, '>', value);

  WhereCondition lessThan(int value) =>
      WhereCondition(name!, '<', value);

  WhereCondition greaterThanOrEqual(int value) =>
      WhereCondition(name!, '>=', value);

  WhereCondition lessThanOrEqual(int value) =>
      WhereCondition(name!, '<=', value);

  WhereCondition between(int min, int max) =>
      WhereCondition(name!, 'BETWEEN', [min, max]);
}

class DoubleColumn extends Column<double> {
  const DoubleColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'doubleType';

  WhereCondition greaterThan(double value) =>
      WhereCondition(name!, '>', value);

  WhereCondition lessThan(double value) =>
      WhereCondition(name!, '<', value);

  WhereCondition greaterThanOrEqual(double value) =>
      WhereCondition(name!, '>=', value);

  WhereCondition lessThanOrEqual(double value) =>
      WhereCondition(name!, '<=', value);

  WhereCondition between(double min, double max) =>
      WhereCondition(name!, 'BETWEEN', [min, max]);
}

/// Maps a Dart [bool] to an integer column (1 for true, 0 for false).
/// Useful for databases like SQLite that lack a native BOOLEAN type.
class BoolColumn extends Column<bool> {
  const BoolColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'boolean';

  WhereCondition isTrue() => WhereCondition(name!, '=', 1);
  WhereCondition isFalse() => WhereCondition(name!, '=', 0);
}

/// Persists [DateTime] objects as ISO-8601 strings to maintain sorting and comparison capabilities.
class DateTimeColumn extends Column<DateTime> {
  const DateTimeColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'datetime';

  WhereCondition after(DateTime value) =>
      WhereCondition(name!, '>', value.toIso8601String());

  WhereCondition before(DateTime value) =>
      WhereCondition(name!, '<', value.toIso8601String());

  WhereCondition between(DateTime start, DateTime end) =>
      WhereCondition(name!, 'BETWEEN', [start, end]);
}

/// Represents a virtual column extracted from a JSON structure using a specific path.
///
/// This does not define a physical column but generates a `json_extract` expression
/// to query nested data within [rootColumn].
class JsonPathColumn<T> extends Column<T> {
  final String rootColumn;
  final String path;

  JsonPathColumn(this.rootColumn, this.path) : super(null);

  @override
  String get schemaType => 'json_path';

  /// Generates the SQL expression to extract the value at [path].
  @override
  String toString() => "json_extract($rootColumn, '\$.$path')";

  WhereCondition greaterThan(num value) => WhereCondition(toString(), '>', value);
  WhereCondition lessThan(num value) => WhereCondition(toString(), '<', value);
  WhereCondition greaterThanOrEqual(num value) => WhereCondition(toString(), '>=', value);
  WhereCondition lessThanOrEqual(num value) => WhereCondition(toString(), '<=', value);
  WhereCondition contains(String value) => WhereCondition(toString(), 'LIKE', '%$value%');

  /// Chains a sub-path to the current JSON extraction path.
  JsonPathColumn<R> key<R>(String subPath) {
    return JsonPathColumn<R>(rootColumn, '$path.$subPath');
  }

  /// Chains an array index selection to the current JSON extraction path.
  JsonPathColumn<R> index<R>(int i) {
    return JsonPathColumn<R>(rootColumn, '$path[$i]');
  }
}

/// A physical column storing arbitrary JSON data.
/// Acts as a factory for [JsonPathColumn] to query internal fields.
class JsonColumn extends Column<dynamic> {
  const JsonColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'json';

  WhereCondition containsPattern(String value) =>
      WhereCondition(name!, 'LIKE', '%$value%');

  /// Creates a virtual column pointing to a specific key within this JSON object.
  JsonPathColumn<T> key<T>(String path) => JsonPathColumn<T>(name!, path);
}

/// Specialized column for storing JSON arrays.
class ArrayColumn extends Column<List<dynamic>> {
  const ArrayColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'array';

  WhereCondition containsPattern(String value) =>
      WhereCondition(name!, 'LIKE', '%$value%');

  /// Creates a virtual column pointing to a specific index within this array.
  JsonPathColumn<T> index<T>(int index) => JsonPathColumn<T>(name!, '[$index]');
}

/// Specialized column for storing JSON objects (Maps).
class ObjectColumn extends Column<Map<String, dynamic>> {
  const ObjectColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'object';

  WhereCondition containsPattern(String value) =>
      WhereCondition(name!, 'LIKE', '%$value%');

  JsonPathColumn<T> key<T>(String path) => JsonPathColumn<T>(name!, path);
}

/// Maps Dart [Enum]s to database strings using the enum's `name`.
class EnumColumn<T extends Enum> extends Column<T> {
  const EnumColumn(super.name, {super.isNullable, super.isGuarded});

  @override
  String get schemaType => 'string';

  @override
  WhereCondition equals(T value) => WhereCondition(name!, '=', value.name);

  @override
  WhereCondition notEquals(T value) => WhereCondition(name!, '!=', value.name);

  @override
  WhereCondition inList(List<T> values) =>
      WhereCondition(name!, 'IN', values.map((e) => e.name).toList());

  @override
  WhereCondition notInList(List<T> values) =>
      WhereCondition(name!, 'NOT IN', values.map((e) => e.name).toList());
}

--- FILE: lib/src/generators/builder.dart ---
import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:source_gen/source_gen.dart';
import 'package:build/build.dart';

import '../../bavard.dart';

/// Entry point for the builder. Generates a `.fillable.g.dart` file containing
/// the mixin implementation for models annotated with `@Fillable`.
Builder fillableGenerator(BuilderOptions options) =>
    LibraryBuilder(FillableGenerator(), generatedExtension: '.fillable.g.dart');

class FillableGenerator extends GeneratorForAnnotation<Fillable> {
  /// Analyzes the `schema` static field to generate strongly-typed accessors,
  /// fillable/guarded lists, and cast maps.
  ///
  /// This relies on AST analysis to parse the `schema` initializer (expected to be a RecordLiteral)
  /// since the column definitions cannot be evaluated at runtime during the build phase.
  @override
  Future<String> generateForAnnotatedElement(
      Element element,
      ConstantReader annotation,
      BuildStep buildStep,
      ) async {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError('@fillable works only on classes.');
    }

    final className = element.name;
    final buffer = StringBuffer();
    final columnsData = <_ColumnInfo>[];

    final schemaField = element.getField('schema');

    // We specifically look for a static field named 'schema'.
    // AST resolution is required here to inspect the literal structure of the field's initializer.
    if (schemaField != null && schemaField.isStatic) {
      AstNode? astNode;

      final resolver = buildStep.resolver as dynamic;

      // Accessing the underlying AST node via fragments to handle recent analyzer API changes.
      final fragment = (schemaField as dynamic).firstFragment;
      astNode = await resolver.astNodeFor(fragment, resolve: true);

      if (astNode is VariableDeclaration) {
        final initializer = astNode.initializer;

        // Expects the schema to be defined as a Record, e.g.: static final schema = ( ... );
        if (initializer is RecordLiteral) {
          for (var field in initializer.fields) {
            if (field is NamedExpression) {
              final propertyName = field.name.label.name;
              final expression = field.expression;

              // Identifies column definitions like `TextColumn('name')`.
              if (expression is InstanceCreationExpression) {
                final typeName = expression.staticType?.element?.name;
                final args = expression.argumentList.arguments;

                // Extract DB column name from the first positional argument.
                String? dbName;
                if (args.isNotEmpty && args.first is SimpleStringLiteral) {
                  dbName = (args.first as SimpleStringLiteral).value;
                }

                bool isNullable = false;
                bool isGuarded = false;

                // Manually parse named arguments for configuration flags since we cannot instantiate the object.
                for (var arg in args) {
                  if (arg is NamedExpression) {
                    final argName = arg.name.label.name;
                    if (arg.expression is BooleanLiteral) {
                      final value = (arg.expression as BooleanLiteral).value;
                      if (argName == 'isNullable') isNullable = value;
                      if (argName == 'isGuarded') isGuarded = value;
                    }
                  }
                }

                String? baseType;
                String? castType;

                // Map ORM column types to Dart primitives.
                switch (typeName) {
                  case 'TextColumn':
                    baseType = 'String';
                    castType = 'string';
                    break;
                  case 'IntColumn':
                  case 'IntegerColumn':
                    baseType = 'int';
                    castType = 'int';
                    break;
                  case 'DoubleColumn':
                    baseType = 'double';
                    castType = 'double';
                    break;
                  case 'BoolColumn':
                  case 'BooleanColumn':
                    baseType = 'bool';
                    castType = 'bool';
                    break;
                  case 'DateTimeColumn':
                    baseType = 'DateTime';
                    castType = 'datetime';
                    break;
                  case 'JsonColumn':
                    baseType = 'dynamic';
                    castType = 'json';
                    break;
                  case 'ArrayColumn':
                    baseType = 'List<dynamic>';
                    castType = 'array';
                    break;
                  case 'ObjectColumn':
                    baseType = 'Map<String, dynamic>';
                    castType = 'object';
                    break;
                }

                if (dbName != null && baseType != null) {
                  final dartType = (isNullable && baseType != 'dynamic')
                      ? '$baseType?'
                      : baseType;

                  columnsData.add(_ColumnInfo(
                    propertyName: propertyName,
                    dbName: dbName,
                    dartType: dartType,
                    castType: castType!,
                    isGuarded: isGuarded,
                  ));
                }
              }
            }
          }
        }
      }
    }

    buffer.writeln("import 'package:bavard/bavard.dart';");
    buffer.writeln();
    buffer.writeln('mixin \$${className}Fillable on Model {');
    buffer.writeln();

    final fillableItems = columnsData
        .where((c) => !c.isGuarded)
        .map((c) => "'${c.dbName}'")
        .join(', ');

    final guardedItems = columnsData
        .where((c) => c.isGuarded)
        .map((c) => "'${c.dbName}'")
        .join(', ');

    buffer.writeln('  /// FILLABLE');
    buffer.writeln('  @override');
    buffer.writeln('  List<String> get fillable => const [$fillableItems];');

    buffer.writeln();
    buffer.writeln('  /// GUARDED');
    buffer.writeln('  @override');
    buffer.writeln('  List<String> get guarded => const [$guardedItems];');

    buffer.writeln();
    buffer.writeln('  /// CASTS');
    buffer.writeln('  @override');
    buffer.writeln('  Map<String, String> get casts => {');
    for (var col in columnsData) {
      buffer.writeln("    '${col.dbName}': '${col.castType}',");
    }
    buffer.writeln('  };');

    // Generate type-safe accessors that proxy to the underlying dynamic `getAttribute` / `setAttribute`.
    for (var col in columnsData) {
      buffer.writeln();
      buffer.writeln('  /// Accessor for [${col.propertyName}] (DB: ${col.dbName})');
      buffer.writeln('  ${col.dartType} get ${col.propertyName} {');
      buffer.writeln("    return getAttribute('${col.dbName}');");
      buffer.writeln('  }');
      buffer.writeln('  set ${col.propertyName}(${col.dartType} value) => setAttribute(\'${col.dbName}\', value);');
    }

    buffer.writeln('}');
    return buffer.toString();
  }
}

class _ColumnInfo {
  final String propertyName;
  final String dbName;
  final String dartType;
  final String castType;
  final bool isGuarded;

  _ColumnInfo({
    required this.propertyName,
    required this.dbName,
    required this.dartType,
    required this.castType,
    required this.isGuarded,
  });
}

--- FILE: lib/src/generators/annotations.dart ---
/// Marks a Model class for code generation.
///
/// Triggers generation of the `.g.dart` part file containing type-safe attribute accessors
/// and mass-assignment logic via [GuardsAttributes.fill].
const fillable = Fillable();

class Fillable {
  const Fillable();
}


--- FILE: lib/src/generators/orm_cast_type.dart ---
/// Canonical mapping between schema type strings and Dart runtime types.
///
/// Used by the code generator to translate `schemaTypes` definitions (e.g., 'json', 'int')
/// into concrete Dart code.
enum OrmCastType {
  string,
  integer,
  doubleType,
  boolean,
  datetime,

  /// Represents complex structures (Maps/Lists) stored as JSON strings.
  json,

  /// Maps to `List<dynamic>`.
  array,

  /// Maps to `Map<String, dynamic>`.
  object;

  /// Resolves a schema type string to an Enum, handling normalization.
  ///
  /// Strips metadata (':guarded') and nullability modifiers ('?', '!') before matching.
  static OrmCastType? fromString(String value) {
    final normalized = value
        .replaceAll('?', '')
        .replaceAll('!', '')
        .toLowerCase();

    switch (normalized) {
      case 'string':
        return OrmCastType.string;
      case 'int':
      case 'integer':
        return OrmCastType.integer;
      case 'double':
      case 'float':
        return OrmCastType.doubleType;
      case 'bool':
      case 'boolean':
        return OrmCastType.boolean;
      case 'datetime':
      case 'date':
        return OrmCastType.datetime;
      case 'json':
        return OrmCastType.json;
      case 'array':
        return OrmCastType.array;
      case 'object':
        return OrmCastType.object;
      default:
        return null;
    }
  }

  /// Parses nullability intent from the type string suffix.
  ///
  /// Defaults to `true` (nullable) to accommodate potential DB nulls,
  /// unless explicitly marked with '!' (strict).
  static bool isNullable(String value) {
    if (value.endsWith('!')) return false;
    if (value.endsWith('?')) return true;
    return true;
  }

  /// Converts the enum to its corresponding Dart type string for code generation.
  String dartType({required bool nullable}) {
    final suffix = nullable ? '?' : '';

    switch (this) {
      case OrmCastType.string:
        return 'String$suffix';
      case OrmCastType.integer:
        return 'int$suffix';
      case OrmCastType.doubleType:
        return 'double$suffix';
      case OrmCastType.boolean:
        return 'bool$suffix';
      case OrmCastType.datetime:
        return 'DateTime$suffix';
      case OrmCastType.json:
        // 'dynamic' avoids generic complexity; nullability is handled by the value check.
        return 'dynamic';
      case OrmCastType.array:
        return 'List<dynamic>$suffix';
      case OrmCastType.object:
        return 'Map<String, dynamic>$suffix';
    }
  }
}


--- FILE: lib/src/core/concerns/has_global_scopes.dart ---
import '../model.dart';
import '../query_builder.dart';
import '../scope.dart';

/// Injects default query constraints (scopes) into the Model's query builder lifecycle.
///
/// Implements cross-cutting concerns like "Soft Deletes" or "Multi-tenancy"
/// by automatically applying WHERE clauses to every new query instance.
mixin HasGlobalScopes on Model {
  List<Scope> get globalScopes => [];

  @override
  void registerGlobalScopes(QueryBuilder<Model> builder) {
    super.registerGlobalScopes(builder);

    for (final scope in globalScopes) {
      builder.withGlobalScope(
        scope.runtimeType.toString(),
        (b) => scope.apply(b, this),
      );
    }
  }

  QueryBuilder<Model> withoutGlobalScopes() {
    return newQuery().withoutGlobalScopes();
  }

  QueryBuilder<Model> withoutGlobalScope<T extends Scope>() {
    return newQuery().withoutGlobalScope(T.toString());
  }
}


--- FILE: lib/src/core/concerns/has_casts.dart ---
import 'dart:convert';

/// Encapsulates type conversion logic for hydrating models from raw data.
///
/// Centralizes parsing rules (String -> int, String -> DateTime, JSON decoding)
/// based on a declarative [casts] configuration, preventing repetitive parsing
/// logic in individual model getters.
mixin HasCasts {
  /// The backing store for raw data, typically mirroring database columns.
  Map<String, dynamic> get attributes;

  /// Configuration map defining how to cast specific attributes.
  ///
  /// Key: Attribute name.
  /// Value: Type identifier (e.g., 'int', 'bool', 'json', 'datetime').
  /// This acts as the schema definition for the model's dynamic data.
  Map<String, String> get casts => {};

  /// Strips modifiers (nullability `?`, `!`) and metadata (suffixes after `:`) to resolve the base type.
  String? _normalizeType(String? value) {
    if (value == null) return null;
    return value.split(':').first.replaceAll('!', '').replaceAll('?', '');
  }

  /// Safe accessor that transforms raw data into type [T] based on [casts].
  ///
  /// Handles distinct parsing strategies:
  /// - Primitives: strict type checks with fallback to `tryParse`.
  /// - Boolean: lenient parsing (supports `true`, `1`, `'true'`, `'1'`).
  /// - JSON: automatically decodes String -> Map/List if type is 'json'/'array'.
  ///
  /// Returns `null` if the key is missing or parsing fails.
  T? getAttribute<T>(String key) {
    final value = attributes[key];
    if (value == null) return null;

    final rawType = casts[key];
    final type = _normalizeType(rawType);

    switch (type) {
      case 'int':
        if (value is int) return value as T;
        if (value is num) return value.toInt() as T;
        return int.tryParse(value.toString()) as T?;

      case 'double':
        if (value is double) return value as T;
        if (value is num) return value.toDouble() as T;
        return double.tryParse(value.toString()) as T?;

      case 'bool':
        if (value is bool) return value as T;
        final s = value.toString().toLowerCase();
        return (s == '1' || s == 'true') as T;

      case 'datetime':
        if (value is DateTime) return value as T;
        return DateTime.tryParse(value.toString()) as T?;

      case 'json':
      case 'array':
      case 'object':
        if (value is String) {
          try {
            return jsonDecode(value) as T;
          } catch (_) {
            return null;
          }
        }
        return value as T;

      default:
        return value as T;
    }
  }

  /// Maps a raw value to a specific [Enum] entry.
  ///
  /// Supports:
  /// - Integer based mapping (index in [values]).
  /// - String based mapping (matches `Enum.name`).
  T? getEnum<T extends Enum>(String key, List<T> values) {
    final val = attributes[key];
    if (val == null) return null;

    if (val is int) {
      if (val >= 0 && val < values.length) return values[val];
    } else {
      final str = val.toString();
      try {
        return values.firstWhere((e) => e.name == str);
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  /// Writes data to [attributes], applying transformations for persistence.
  ///
  /// Key transformations:
  /// - Enums -> name string.
  /// - Complex objects/collections -> JSON encoded string (tries `.toJson()` first).
  /// - Bool -> integer (1/0) for broad SQL compatibility.
  /// - DateTime -> ISO-8601 string.
  void setAttribute(String key, dynamic value) {
    final rawType = casts[key];
    final type = _normalizeType(rawType);

    if (value == null) {
      attributes[key] = null;
      return;
    }

    if (value is Enum) {
      attributes[key] = value.name;
      return;
    }

    switch (type) {
      case 'json':
      case 'array':
      case 'object':
        if (value is! String) {
          try {
            // Prioritizes .toJson() for custom objects, falls back to primitive encoding.
            attributes[key] = jsonEncode((value as dynamic).toJson());
          } catch (_) {
            attributes[key] = jsonEncode(value);
          }
        } else {
          attributes[key] = value;
        }
        break;

      case 'bool':
        attributes[key] = (value == true) ? 1 : 0;
        break;

      case 'datetime':
        if (value is DateTime) {
          attributes[key] = value.toIso8601String();
        } else {
          attributes[key] = value;
        }
        break;

      default:
        attributes[key] = value;
    }
  }
}


--- FILE: lib/src/core/concerns/has_uuids.dart ---
import 'package:uuid/uuid.dart';
import '../model.dart';

/// Enforces client-side UUID generation for Primary Keys (UUID v4).
///
/// Ideal for distributed systems or offline-first architectures where
/// records must have a guaranteed unique identity before reaching the central database.
mixin HasUuids on Model {
  /// Pre-save hook: Lazily assigns a UUID v4 if the ID is missing.
  ///
  /// Prevents database round-trips for ID generation and allows for
  /// immediate reference to the object in relations/UI before persistence.
  @override
  Future<bool> onSaving() async {
    id ??= const Uuid().v4();
    return super.onSaving();
  }

  /// Signals the ORM that the Primary Key is not database-managed (auto-increment).
  ///
  /// This prevents the framework from attempting to retrieve the "last inserted ID"
  /// and ensures the ID is treated as a string rather than an integer.
  bool get incrementing => false;
}


--- FILE: lib/src/core/concerns/has_timestamps.dart ---
import '../model.dart';

/// Automates the maintenance of audit timestamps (`created_at`, `updated_at`) during persistence.
mixin HasTimestamps on Model {
  String get createdAtColumn => 'created_at';

  String get updatedAtColumn => 'updated_at';

  /// Master toggle to disable auto-timestamping (e.g., for legacy tables or bulk imports).
  bool get timestamps => true;

  /// Hooks into the save lifecycle to inject current timestamps.
  ///
  /// Logic:
  /// 1. New records (`id` is null): Sets `created_at` (unless manually populated).
  /// 2. All saves: Refreshes `updated_at` to the current time.
  @override
  Future<bool> onSaving() async {
    if (!timestamps) return super.onSaving();

    final now = DateTime.now();

    // Differentiates 'Create' from 'Update' based on the existence of a Primary Key.
    if (!exists) {
      // Respects manually set creation dates (e.g., during data migration).
      if (attributes[createdAtColumn] == null) {
        setAttribute(createdAtColumn, now);
      }
    }

    setAttribute(updatedAtColumn, now);
    return super.onSaving();
  }
}


--- FILE: lib/src/core/concerns/has_relationships.dart ---
import '../model.dart';
import '../utils.dart';
import '../../relations/relation.dart';
import '../../relations/has_one.dart';
import '../../relations/has_many.dart';
import '../../relations/belongs_to.dart';
import '../../relations/belongs_to_many.dart';
import '../../relations/has_many_through.dart';
import '../../relations/morph_many.dart';
import '../../relations/morph_one.dart';
import '../../relations/morph_to.dart';
import '../../relations/morph_to_many.dart';

/// Provides a DSL for defining Eloquent-style relationships.
///
/// Relies heavily on "Convention over Configuration" to infer Foreign/Local keys
/// based on model class names and table definitions, unless explicitly overridden.
mixin HasRelationships {
  // --- Abstract Requirements ---

  /// The table name of the current model, used to generate default Foreign Keys (e.g., `user_id`).
  String get table;

  /// The primary key value, required to bind relation queries to this specific instance.
  dynamic get id;

  /// The primary key column name (usually 'id').
  String get primaryKey;

  /// Cache registry for eager-loaded relationships to prevent N+1 queries.
  Map<String, dynamic> get relations;

  /// Accessor for hydration logic to retrieve cached/eager-loaded data.
  Relation? getRelation(String name) => null;

  /// Helper casting to [Model] to satisfy strict typing in relation constructors.
  Model get _asModel => this as Model;

  // --- Relationship Definitions ---

  /// Defines a 1:1 relationship where the Foreign Key resides on the related model [R].
  ///
  /// Example: User has one Phone. (Phone table has `user_id`).
  HasOne<R> hasOne<R extends Model>(
    R Function(Map<String, dynamic>) creator, {
    String? foreignKey,
    String? localKey,
  }) {
    return HasOne<R>(
      _asModel,
      creator,
      foreignKey ?? Utils.foreignKey(table),
      localKey ?? primaryKey,
    );
  }

  /// Defines a 1:N relationship where the Foreign Key resides on the related model [R].
  ///
  /// Example: Blog has many Posts. (Post table has `blog_id`).
  HasMany<R> hasMany<R extends Model>(
    R Function(Map<String, dynamic>) creator, {
    String? foreignKey,
    String? localKey,
  }) {
    return HasMany<R>(
      _asModel,
      creator,
      foreignKey ?? Utils.foreignKey(table),
      localKey ?? primaryKey,
    );
  }

  /// Defines an inverse 1:1 or N:1 relationship where the Foreign Key resides on *this* model.
  ///
  /// Example: Post belongs to User. (Post table has `user_id`).
  ///
  /// Note: Instantiates a temporary [R] to inspect its `table` and `primaryKey`
  /// for default key inference.
  BelongsTo<R> belongsTo<R extends Model>(
    R Function(Map<String, dynamic>) creator, {
    String? foreignKey,
    String? ownerKey,
  }) {
    // We create a dummy instance to inspect the parent's table and primary key defaults.
    final instance = creator({});
    return BelongsTo<R>(
      _asModel,
      creator,
      foreignKey ?? Utils.foreignKey(instance.table),
      ownerKey ?? instance.primaryKey,
    );
  }

  /// Defines a N:N relationship via an intermediate pivot table.
  ///
  /// Example: User belongs to many Roles (via `role_user` table).
  ///
  /// * [pivotTable]: Explicit name required if strictly following convention isn't possible or desired.
  BelongsToMany<R> belongsToMany<R extends Model>(
    R Function(Map<String, dynamic>) creator,
    String pivotTable, {
    String? foreignPivotKey,
    String? relatedPivotKey,
  }) {
    final instance = creator({});
    return BelongsToMany<R>(
      _asModel,
      creator,
      pivotTable,
      foreignPivotKey ?? Utils.foreignKey(table),
      relatedPivotKey ?? Utils.foreignKey(instance.table),
    );
  }

  /// Defines a distant 1:N relationship through an intermediate model.
  ///
  /// Example: Country has many Posts through User.
  /// (Country -> User -> Post). Useful to avoid manual nested joins.
  HasManyThrough<R, I> hasManyThrough<R extends Model, I extends Model>(
    R Function(Map<String, dynamic>) relatedCreator,
    I Function(Map<String, dynamic>) intermediateCreator, {
    String? firstKey,
    String? secondKey,
  }) {
    return HasManyThrough<R, I>(
      _asModel,
      relatedCreator,
      intermediateCreator,
      firstKey,
      secondKey,
    );
  }

  // --- Polymorphic Relationships ---

  /// Polymorphic 1:N. The target model [R] stores the `_id` and `_type`.
  ///
  /// Example: Post has many Comments (and Video also has many Comments).
  MorphMany<R> morphMany<R extends Model>(
    R Function(Map<String, dynamic>) creator,
    String name,
  ) {
    return MorphMany<R>(_asModel, creator, name);
  }

  /// Polymorphic 1:1. Similar to [morphMany] but enforces a single result.
  MorphOne<R> morphOne<R extends Model>(
    R Function(Map<String, dynamic>) creator,
    String name,
  ) {
    return MorphOne<R>(_asModel, creator, name);
  }

  /// The inverse of a polymorphic relationship (the child side).
  ///
  /// Used by the model holding the `_id` and `_type` columns (e.g., Comment)
  /// to resolve its parent, which could be one of several types.
  ///
  /// * [typeMap]: Maps the stored string discriminator (e.g., 'post') to the concrete Model factory.
  MorphTo<Model> morphToTyped(
    String name,
    Map<String, Model Function(Map<String, dynamic>)> typeMap,
  ) {
    return MorphTo<Model>(_asModel, name, typeMap);
  }

  /// Polymorphic N:N.
  ///
  /// Allows a model to belong to many other models of different types via a pivot table
  /// that includes type discriminators.
  MorphToMany<R> morphToMany<R extends Model>(
    R Function(Map<String, dynamic>) creator,
    String name,
  ) {
    return MorphToMany<R>(_asModel, creator, name);
  }
}


--- FILE: lib/src/core/concerns/has_attribute_helpers.dart ---
import 'has_casts.dart';

/// Provides syntactic sugar over [HasCasts] for typed attribute access.
///
/// Reduces boilerplate for common primitives and enables Map-like subscript
/// syntax (e.g., `model['key']`) to facilitate dynamic access or generic UI binding.
mixin HasAttributeHelpers on HasCasts {
  String? string(String key) => getAttribute<String>(key);

  int? integer(String key) => getAttribute<int>(key);

  double? doubleNum(String key) => getAttribute<double>(key);

  bool? boolean(String key) => getAttribute<bool>(key);

  DateTime? date(String key) => getAttribute<DateTime>(key);

  /// Helper for retrieving nested structures (e.g., `Map` or `List`) cast to [T].
  T? json<T>(String key) => getAttribute<T>(key);

  /// Resolves the raw value at [key] to a specific [Enum] entry within [values].
  T? enumeration<T extends Enum>(String key, List<T> values) =>
      getEnum<T>(key, values);

  /// Exposes dynamic access, useful for serialization loops or form field binding.
  dynamic operator [](String key) => getAttribute(key);

  void operator []=(String key, dynamic value) => setAttribute(key, value);
}


--- FILE: lib/src/core/concerns/has_guards_attributes.dart ---
/// Implements Mass Assignment protection to secure models against unsafe data injection.
///
/// Prevents sensitive attributes (e.g., `is_admin`, `id`) from being overwritten
/// by raw input maps. Uses a priority system: Global Unguard > Whitelist ([fillable]) > Blacklist ([guarded]).
mixin HasGuardsAttributes {
  /// Attributes explicitly allowed for bulk assignment (whitelist).
  ///
  /// If populated, ONLY these keys are accepted by [fill]; [guarded] becomes irrelevant.
  List<String> get fillable => [];

  /// Attributes blocked from bulk assignment (blacklist).
  ///
  /// Defaults to `['*']` (deny-all) for security. Only active if [fillable] is empty.
  List<String> get guarded => ['*'];

  static bool _unguarded = false;

  /// Globally disables protection. Use strictly for trusted contexts (seeders, migrations, tests).
  static void unguard([bool state = true]) => _unguarded = state;

  /// Re-enables global protection.
  static void reguard() => _unguarded = false;

  /// Safely hydrates the model from [attributes], filtering out forbidden keys.
  ///
  /// Relies on dynamic dispatch to invoke `setAttribute` (typically provided by `HasCasts`).
  void fill(Map<String, dynamic> attributes) {
    attributes.forEach((key, value) {
      if (isFillable(key)) {
        (this as dynamic).setAttribute(key, value);
      }
    });
  }

  /// Bypasses all security guards to set attributes.
  ///
  /// **Security Risk**: Use only for trusted internal operations.
  void forceFill(Map<String, dynamic> attributes) {
    attributes.forEach((key, value) {
      (this as dynamic).setAttribute(key, value);
    });
  }

  /// Determines if [key] is safe to write.
  ///
  /// Resolution order:
  /// 1. Global unguard check.
  /// 2. Whitelist check (if [fillable] is not empty).
  /// 3. Blacklist check (against [guarded]).
  bool isFillable(String key) {
    if (_unguarded) return true;

    // Whitelist mode: strict adherence to fillable.
    if (fillable.contains(key)) {
      return true;
    }
    if (fillable.isNotEmpty) {
      return false;
    }

    // Blacklist mode: defaults to deny-all ('*') if no specific rules exist.
    if (guarded.contains('*') || guarded.contains(key)) {
      return false;
    }

    return true;
  }
}


--- FILE: lib/src/core/concerns/has_soft_deletes.dart ---
import '../model.dart';
import '../query_builder.dart';

/// Implements the "Soft Delete" pattern using a `deleted_at` timestamp.
///
/// Modifies the model's behavior so that "deletion" updates a timestamp rather
/// than removing the row. Automatically filters out these rows from standard queries.
mixin HasSoftDeletes on Model {
  bool get trashed => attributes['deleted_at'] != null;

  @override
  void registerGlobalScopes(QueryBuilder<Model> builder) {
    super.registerGlobalScopes(builder);

    builder.withGlobalScope('soft_delete', (b) {
      b.whereNull('deleted_at');
    });
  }

  /// Bypasses the default soft-delete scope to retrieve all records (active + deleted).
  QueryBuilder<Model> withTrashed() {
    return newQuery().withoutGlobalScope('soft_delete');
  }

  /// Scopes the query to retrieve **only** soft-deleted records.
  QueryBuilder<Model> onlyTrashed() {
    return newQuery()
        .withoutGlobalScope('soft_delete')
        .whereNotNull('deleted_at');
  }

  /// Overrides physical deletion to perform an `UPDATE` operation.
  ///
  /// Sets `deleted_at` to the current time instead of removing the row.
  /// Maintains standard lifecycle hooks ([onDeleting] / [onDeleted]).
  @override
  Future<void> delete() async {
    if (id != null && await onDeleting()) {
      setAttribute('deleted_at', DateTime.now());

      await save();
      await onDeleted();
    }
  }

  /// Reverses a soft-delete by resetting `deleted_at` to null.
  Future<void> restore() async {
    setAttribute('deleted_at', null);
    await save();
  }

  /// Permanently removes the record from the database (SQL DELETE).
  ///
  /// **Warning:** Data loss is irreversible.
  /// Still triggers standard [onDeleting] and [onDeleted] hooks for consistency.
  Future<void> forceDelete() async {
    if (id != null && await onDeleting()) {
      await newQuery().withoutGlobalScopes().where(primaryKey, id).delete();
      await onDeleted();
    }
  }
}


--- FILE: lib/src/core/concerns/has_events.dart ---
/// Defines interception points for persistence lifecycle (ORM-style hooks).
///
/// Allows implementing cross-cutting concerns like validation, cascading updates,
/// or external side effects during the Save/Delete transaction flow.
mixin HasEvents {
  /// Pre-persistence hook. Return `false` to abort the Save operation.
  ///
  /// Useful for final validation, setting automated timestamps (e.g., `updated_at`),
  /// or calculating derived fields before the data hits the storage.
  Future<bool> onSaving() async => true;

  /// Post-persistence hook invoked after the record is committed.
  ///
  /// Safe for side effects that require the record to definitely exist in the DB,
  /// such as invalidating cache, triggering webhooks, or scheduling background jobs.
  Future<void> onSaved() async {}

  /// Pre-removal hook. Return `false` to prevent the Delete operation.
  ///
  /// Critical for referential integrity checks (e.g., preventing delete if dependencies exist)
  /// or business rule enforcement (e.g., "cannot delete the last admin").
  Future<bool> onDeleting() async => true;

  /// Post-removal hook.
  ///
  /// Ideal for cleanup of non-database resources (file system assets, cloud storage images)
  /// or broadcasting deletion events to other parts of the app.
  Future<void> onDeleted() async {}
}


--- FILE: test/core/model_operators_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class HelperUser extends Model {
  @override
  String get table => 'users';

  HelperUser([super.attributes]);

  @override
  HelperUser fromMap(Map<String, dynamic> map) => HelperUser(map);

  @override
  Map<String, String> get casts => {
    'settings': 'json',
    'is_active': 'bool',
    'age': 'int',
    'score': 'double',
    'created_at': 'datetime',
  };
}

void main() {
  setUp(() {
    DatabaseManager().setDatabase(MockDatabaseSpy());
  });

  group('HasAttributeHelpers Mixin', () {
    test('Semantic helpers return correct types respecting casts', () {
      final user = HelperUser({
        'age': '25',
        'is_active': 1,
        'score': '99.5',
        'created_at': '2023-01-01T10:00:00.000',
        'name': 'David',
      });

      expect(user.integer('age'), isA<int>());
      expect(user.integer('age'), 25);

      expect(user.boolean('is_active'), isTrue);

      expect(user.doubleNum('score'), 99.5);

      expect(user.date('created_at'), isA<DateTime>());
      expect(user.date('created_at')?.year, 2023);

      expect(user.string('name'), 'David');
    });

    test('json() helper correctly decodes Map/List', () {
      final user = HelperUser({'settings': '{"theme":"dark"}'});

      final Map<String, dynamic>? settings = user.json('settings');

      expect(settings, isNotNull);
      expect(settings!['theme'], 'dark');
    });

    test('Operators [] and []= still work via mixin', () {
      final user = HelperUser();
      user['age'] = 30;
      expect(user.integer('age'), 30);
      expect(user['age'], 30);
    });
  });
}


--- FILE: test/core/typed_query_applies_model_newquery_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class SoftUser extends Model with HasSoftDeletes {
  @override
  String get table => 'users';

  SoftUser([super.attributes]);

  @override
  SoftUser fromMap(Map<String, dynamic> map) => SoftUser(map);

  @override
  Map<String, String> get casts => {'deleted_at': 'datetime'};
}

class AgeScope implements Scope {
  @override
  void apply(QueryBuilder builder, Model model) {
    builder.where('age', 18, '>=');
  }
}

class ActiveScope implements Scope {
  @override
  void apply(QueryBuilder builder, Model model) {
    builder.where('is_active', 1);
  }
}

class ScopedUser extends Model with HasGlobalScopes {
  @override
  String get table => 'users';

  @override
  List<Scope> get globalScopes => [AgeScope(), ActiveScope()];

  ScopedUser([super.attributes]);

  @override
  ScopedUser fromMap(Map<String, dynamic> map) => ScopedUser(map);
}

void main() {
  group('TypedQuery.query() respects Model.query() overrides', () {
    test('SoftDeletes is applied also via typed query()', () async {
      final dbSpy = MockDatabaseSpy();
      DatabaseManager().setDatabase(dbSpy);

      await SoftUser().query().get();

      expect(dbSpy.lastSql, contains('WHERE "deleted_at" IS NULL'));
    });

    test('HasGlobalScopes are applied also via typed query()', () async {
      final dbSpy = MockDatabaseSpy();
      DatabaseManager().setDatabase(dbSpy);

      await ScopedUser().query().get();

      expect(dbSpy.lastSql, contains('"age" >= ?'));
      expect(dbSpy.lastSql, contains('"is_active" = ?'));

      expect(dbSpy.lastArgs, isNotNull);
      expect(dbSpy.lastArgs, contains(18));
      expect(dbSpy.lastArgs, contains(1));
    });
  });
}


--- FILE: test/core/database_manager_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

void main() {
  group('DatabaseManager', () {
    test('singleton returns same instance', () {
      final instance1 = DatabaseManager();
      final instance2 = DatabaseManager();

      expect(identical(instance1, instance2), isTrue);
    });

    test('setDatabase replaces existing adapter', () async {
      final firstAdapter = MockDatabaseSpy([], {
        'FROM test': [
          {'id': 1},
        ],
      });
      final secondAdapter = MockDatabaseSpy([], {
        'FROM test': [
          {'id': 2},
        ],
      });

      DatabaseManager().setDatabase(firstAdapter);
      expect(DatabaseManager().db, firstAdapter);

      DatabaseManager().setDatabase(secondAdapter);
      expect(DatabaseManager().db, secondAdapter);
    });

    test('db getter returns set adapter', () {
      final adapter = MockDatabaseSpy();
      DatabaseManager().setDatabase(adapter);

      expect(DatabaseManager().db, adapter);
    });

    test('inTransaction returns false by default', () {
      DatabaseManager().setDatabase(MockDatabaseSpy());

      expect(DatabaseManager().inTransaction, isFalse);
    });

    test('activeTransaction returns null by default', () {
      DatabaseManager().setDatabase(MockDatabaseSpy());

      expect(DatabaseManager().activeTransaction, isNull);
    });
  });
}


--- FILE: test/core/utils_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';

void main() {
  group('Utils Helper', () {
    test('singularize() handles standard plurals', () {
      expect(Utils.singularize('users'), 'user');
      expect(Utils.singularize('posts'), 'post');
      expect(Utils.singularize('comments'), 'comment');
    });

    test('singularize() handles -ies suffix', () {
      expect(Utils.singularize('categories'), 'category');
      expect(Utils.singularize('countries'), 'country');
      expect(Utils.singularize('companies'), 'company');
    });

    test('singularize() handles words ending in s but not plural', () {
      expect(Utils.singularize('process'), 'process');
      expect(Utils.singularize('status'), 'statu');
    });

    test('foreignKey() generates correct snake_case keys', () {
      expect(Utils.foreignKey('users'), 'user_id');
      expect(Utils.foreignKey('categories'), 'category_id');
      expect(Utils.foreignKey('user_roles'), 'user_role_id');
    });
  });
  group('Utils.singularize', () {
    test('handles regular plurals', () {
      expect(Utils.singularize('users'), 'user');
      expect(Utils.singularize('posts'), 'post');
      expect(Utils.singularize('comments'), 'comment');
      expect(Utils.singularize('profiles'), 'profile');
    });

    test('handles -ies suffix', () {
      expect(Utils.singularize('categories'), 'category');
      expect(Utils.singularize('countries'), 'country');
      expect(Utils.singularize('companies'), 'company');
      expect(Utils.singularize('cities'), 'city');
    });

    test('handles -es suffix for certain words', () {
      expect(Utils.singularize('boxes'), 'boxe'); // Simple implementation
      expect(Utils.singularize('watches'), 'watche');
    });

    test('handles already singular words', () {
      expect(Utils.singularize('user'), 'user');
      expect(Utils.singularize('post'), 'post');
      expect(Utils.singularize('data'), 'data');
    });

    test('handles empty string', () {
      expect(Utils.singularize(''), '');
    });

    test('handles single character', () {
      expect(Utils.singularize('s'), '');
      expect(Utils.singularize('a'), 'a');
    });

    test('handles words ending in ss (not plural)', () {
      expect(Utils.singularize('process'), 'process');
      expect(Utils.singularize('class'), 'class');
      expect(Utils.singularize('address'), 'address');
    });
  });

  group('Utils.foreignKey', () {
    test('with single word table', () {
      expect(Utils.foreignKey('users'), 'user_id');
      expect(Utils.foreignKey('posts'), 'post_id');
    });

    test('with multi-word table', () {
      expect(Utils.foreignKey('user_roles'), 'user_role_id');
      expect(Utils.foreignKey('blog_posts'), 'blog_post_id');
    });

    test('with already singular name', () {
      expect(Utils.foreignKey('user'), 'user_id');
      expect(Utils.foreignKey('post'), 'post_id');
    });

    test('with -ies plural', () {
      expect(Utils.foreignKey('categories'), 'category_id');
      expect(Utils.foreignKey('countries'), 'country_id');
    });
  });
}


--- FILE: test/core/model_save_failure_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class FailingMockDatabase extends MockDatabaseSpy {
  bool shouldFailInsert = false;
  bool shouldFailUpdate = false;

  FailingMockDatabase() : super();

  @override
  Future<dynamic> insert(String table, Map<String, dynamic> values) async {
    if (shouldFailInsert) {
      throw Exception('Database insert failed');
    }
    return super.insert(table, values);
  }

  @override
  Future<int> execute(String sql, [List<dynamic>? arguments]) async {
    if (shouldFailUpdate && sql.contains('UPDATE')) {
      throw Exception('Database update failed');
    }
    return super.execute(sql, arguments);
  }
}

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

void main() {
  group('Model State After Failed Operations', () {
    test('model state remains consistent after failed INSERT', () async {
      final failingDb = FailingMockDatabase();
      failingDb.shouldFailInsert = true;
      DatabaseManager().setDatabase(failingDb);

      final user = User({'name': 'David'});

      expect(user.exists, isFalse);
      expect(user.id, isNull);

      try {
        await user.save();
        fail('Should have thrown');
      } catch (e) {
        expect(e, isA<Exception>());
      }

      expect(
        user.exists,
        isFalse,
        reason: 'exists should remain false after failed insert',
      );
    });

    test('model state remains consistent after failed UPDATE', () async {
      final failingDb = FailingMockDatabase();
      DatabaseManager().setDatabase(failingDb);

      final user = User({'id': 1, 'name': 'David', 'email': 'old@test.com'});
      user.exists = true;
      user.syncOriginal();

      user.attributes['email'] = 'new@test.com';

      failingDb.shouldFailUpdate = true;

      try {
        await user.save();
        fail('Should have thrown');
      } catch (e) {
        expect(e, isA<Exception>());
      }

      expect(user.exists, isTrue);
      expect(user.attributes['email'], 'new@test.com');
      expect(user.original['email'], 'old@test.com');
    });

    test('dirty checking works correctly after failed save', () async {
      final failingDb = FailingMockDatabase();
      DatabaseManager().setDatabase(failingDb);

      final user = User({'id': 1, 'name': 'David'});
      user.exists = true;
      user.syncOriginal();

      user.attributes['name'] = 'Updated';
      failingDb.shouldFailUpdate = true;

      try {
        await user.save();
      } catch (e) {
        // Ignore errors.
      }

      // Model is still dirty.
      expect(user.attributes['name'], isNot(equals(user.original['name'])));

      final workingDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 1, 'name': 'Updated'},
        ],
      });
      DatabaseManager().setDatabase(workingDb);

      await user.save();

      expect(workingDb.history.any((s) => s.contains('UPDATE')), isTrue);
    });
  });
}


--- FILE: test/core/transaction_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';

  User([super.attributes]);

  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

class Profile extends Model {
  @override
  String get table => 'profiles';

  Profile([super.attributes]);

  @override
  Profile fromMap(Map<String, dynamic> map) => Profile(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'last_insert_row_id': [
        {'id': 1},
      ],
      'FROM users': [
        {'id': 1, 'name': 'David'},
      ],
      'FROM profiles': [
        {'id': 1, 'user_id': 1, 'bio': 'Test bio'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Transaction Support', () {
    test('transaction() executes callback and commits on success', () async {
      await DatabaseManager().transaction((txn) async {
        final user = User({'name': 'David'});
        await user.save();
        return user;
      });

      expect(dbSpy.history, contains('BEGIN TRANSACTION'));
      expect(dbSpy.history, contains('COMMIT'));
      expect(dbSpy.history, isNot(contains('ROLLBACK')));
    });

    test('transaction() rolls back on exception', () async {
      dbSpy.shouldFailTransaction = true;

      try {
        await DatabaseManager().transaction((txn) async {
          final user = User({'name': 'David'});
          await user.save();
          return user;
        });
        fail('Should have thrown');
      } catch (e) {
        expect(e, isA<TransactionException>());
      }

      expect(dbSpy.history, contains('BEGIN TRANSACTION'));
      expect(dbSpy.history, contains('ROLLBACK'));
      expect(dbSpy.history, isNot(contains('COMMIT')));
    });

    test('inTransaction returns correct state', () async {
      expect(DatabaseManager().inTransaction, isFalse);

      await DatabaseManager().transaction((txn) async {
        expect(DatabaseManager().inTransaction, isTrue);
        return null;
      });

      expect(DatabaseManager().inTransaction, isFalse);
    });

    test('multiple model operations participate in same transaction', () async {
      await DatabaseManager().transaction((txn) async {
        final user = User({'name': 'David'});
        await user.save();

        final profile = Profile({'user_id': 1, 'bio': 'Test'});
        await profile.save();

        return null;
      });

      // Verify both inserts happened within transaction
      final insertCount = dbSpy.transactionHistory
          .where((s) => s.contains('INSERT'))
          .length;
      expect(insertCount, 2);
    });

    test('TransactionException contains original error', () async {
      dbSpy.shouldFailTransaction = true;

      try {
        await DatabaseManager().transaction((txn) async {
          await txn.execute('INVALID SQL');
        });
        fail('Should have thrown');
      } catch (e) {
        expect(e, isA<TransactionException>());
        final txnError = e as TransactionException;
        expect(txnError.wasRolledBack, isTrue);
        expect(txnError.originalError, isNotNull);
      }
    });
  });
}


--- FILE: test/core/exceptions_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';

  User([super.attributes]);

  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

void main() {
  group('Exceptions', () {
    group('ModelNotFoundException', () {
      test(
        'findOrFail() throws ModelNotFoundException when not found',
        () async {
          final emptyMock = MockDatabaseSpy([], {});
          DatabaseManager().setDatabase(emptyMock);

          try {
            await User().query().findOrFail(999);
            fail('Should have thrown ModelNotFoundException');
          } catch (e) {
            expect(e, isA<ModelNotFoundException>());
            final error = e as ModelNotFoundException;
            expect(error.model, 'users');
            expect(error.id, 999);
            expect(error.message, contains('999'));
          }
        },
      );

      test('firstOrFail() throws ModelNotFoundException when empty', () async {
        final emptyMock = MockDatabaseSpy([], {});
        DatabaseManager().setDatabase(emptyMock);

        try {
          await User().query().where('id', 1).firstOrFail();
          fail('Should have thrown ModelNotFoundException');
        } catch (e) {
          expect(e, isA<ModelNotFoundException>());
          final error = e as ModelNotFoundException;
          expect(error.model, 'users');
        }
      });
    });

    group('DatabaseNotInitializedException', () {
      test('throws when database not initialized', () {
        // Create a new DatabaseManager instance to test uninitialized state
        // In real code, we'd need to reset the singleton
        // For this test, we verify the exception type exists and formats correctly
        const exception = DatabaseNotInitializedException();

        expect(exception.message, contains('not initialized'));
        expect(
          exception.toString(),
          contains('DatabaseNotInitializedException'),
        );
      });
    });

    group('InvalidQueryException', () {
      test('thrown for invalid column identifiers', () {
        expect(
          () => User().query().where('column; DROP TABLE', 'value'),
          throwsA(isA<InvalidQueryException>()),
        );
      });

      test('thrown for invalid operators', () {
        expect(
          () => User().query().where('id', 1, 'INVALID'),
          throwsA(isA<InvalidQueryException>()),
        );
      });

      test('thrown for invalid orderBy direction', () {
        expect(
          () => User().query().orderBy('id', direction: 'INVALID'),
          throwsA(isA<InvalidQueryException>()),
        );
      });
    });

    group('QueryException', () {
      test('contains SQL and bindings information', () {
        const exception = QueryException(
          sql: 'SELECT * FROM users WHERE id = ?',
          bindings: [1],
          message: 'Test error',
        );

        expect(exception.sql, 'SELECT * FROM users WHERE id = ?');
        expect(exception.bindings, [1]);
        expect(exception.toString(), contains('SELECT * FROM users'));
        expect(exception.toString(), contains('Test error'));
      });
    });

    group('TransactionException', () {
      test('contains rollback status', () {
        const exception = TransactionException(
          message: 'Transaction failed',
          wasRolledBack: true,
        );

        expect(exception.wasRolledBack, isTrue);
        expect(exception.toString(), contains('Rolled back: true'));
      });
    });

    group('MassAssignmentException', () {
      test('formats message correctly', () {
        const exception = MassAssignmentException(
          attribute: 'is_admin',
          model: 'User',
        );

        expect(exception.message, contains('is_admin'));
        expect(exception.message, contains('User'));
        expect(exception.toString(), contains('MassAssignmentException'));
      });
    });

    group('RelationNotFoundException', () {
      test('formats message correctly', () {
        const exception = RelationNotFoundException(
          relation: 'posts',
          model: 'User',
        );

        expect(exception.message, contains('posts'));
        expect(exception.message, contains('User'));
      });
    });

    group('Exception Hierarchy', () {
      test('all exceptions extend ActiveSyncException', () {
        expect(
          const ModelNotFoundException(model: 'User'),
          isA<BavardException>(),
        );
        expect(
          const QueryException(sql: '', message: ''),
          isA<BavardException>(),
        );
        expect(const TransactionException(message: ''), isA<BavardException>());
        expect(const DatabaseNotInitializedException(), isA<BavardException>());
        expect(const InvalidQueryException(''), isA<BavardException>());
        expect(
          const MassAssignmentException(attribute: '', model: ''),
          isA<BavardException>(),
        );
        expect(
          const RelationNotFoundException(relation: '', model: ''),
          isA<BavardException>(),
        );
      });

      test('can catch all ORM exceptions with base type', () {
        try {
          throw const ModelNotFoundException(model: 'User');
        } on BavardException catch (e) {
          expect(e, isNotNull);
        }
      });
    });
  });
}


--- FILE: test/core/query_builder_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class TestUser extends Model {
  @override
  String get table => 'users';
  TestUser([super.attributes]);
  @override
  TestUser fromMap(Map<String, dynamic> map) => TestUser(map);
}

class AdminView extends Model {
  @override
  String get table => 'users';

  AdminView([super.attributes]);

  @override
  AdminView fromMap(Map<String, dynamic> map) => AdminView(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  test('It generates basic SELECT *', () async {
    await TestUser().query().get();
    expect(dbSpy.lastSql, 'SELECT "users".* FROM "users"');
  });

  test('It generates WHERE clauses with bindings', () async {
    await TestUser().where('email', 'david@test.com').get();

    expect(dbSpy.lastSql, contains('WHERE "email" = ?'));
    expect(dbSpy.lastArgs, ['david@test.com']);
  });

  test('It chains multiple WHERE clauses', () async {
    await TestUser()
        .query()
        .where('role', 'admin')
        .where('age', 18, '>')
        .get();

    final q = TestUser().where('role', 'admin').where('age', 18, '>');
    await q.get();

    expect(dbSpy.lastSql, contains('WHERE "role" = ? AND "age" > ?'));
    expect(dbSpy.lastArgs, ['admin', 18]);
  });

  test('It generates ORDER BY and LIMIT', () async {
    await TestUser()
        .query()
        .orderBy('created_at', direction: 'DESC')
        .limit(5)
        .get();

    expect(dbSpy.lastSql, contains('ORDER BY "created_at" DESC'));
    expect(dbSpy.lastSql, contains('LIMIT 5'));
  });

  test('It handles WHERE IN', () async {
    await TestUser().query().whereIn('id', [1, 2, 3]).get();

    expect(dbSpy.lastSql, contains('"id" IN (?, ?, ?)'));
    expect(dbSpy.lastArgs, [1, 2, 3]);
  });

  test('orderBy accepts dotted identifiers (table.column)', () async {
    await TestUser()
        .query()
        .orderBy('users.created_at', direction: 'DESC')
        .get();

    expect(dbSpy.lastSql, contains('ORDER BY "users"."created_at" DESC'));
  });

  test('orderBy accepts dotted identifiers (table.column)', () async {
    await TestUser()
        .query()
        .orderBy('users.created_at', direction: 'DESC')
        .get();

    expect(dbSpy.lastSql, contains('ORDER BY "users"."created_at" DESC'));
  });

  test('orderBy rejects injection attempts in identifier', () async {
    expect(
      () => TestUser().query().orderBy(
        'users.created_at; DROP TABLE users',
        direction: 'DESC',
      ),
      throwsA(isA<InvalidQueryException>()),
    );
  });

  test('It handles OR WHERE clauses', () async {
    await TestUser()
        .query()
        .where('id', 1)
        .orWhere('email', 'admin@test.com')
        .get();

    expect(dbSpy.lastSql, contains('WHERE "id" = ? OR "email" = ?'));
    expect(dbSpy.lastArgs, [1, 'admin@test.com']);
  });

  test('It handles whereNull and whereNotNull', () async {
    final q = TestUser()
        .query()
        .whereNull('deleted_at')
        .orWhereNotNull('posted_at');
    await q.get();

    expect(
      dbSpy.lastSql,
      contains('WHERE "deleted_at" IS NULL OR "posted_at" IS NOT NULL'),
    );
    expect(dbSpy.lastArgs, isEmpty);
  });

  test('It handles whereRaw with bindings', () async {
    await TestUser().query().whereRaw('age > ?', bindings: [18]).get();

    expect(dbSpy.lastSql, contains('WHERE age > ?'));
    expect(dbSpy.lastArgs, [18]);
  });

  test('It handles orWhereRaw with bindings', () async {
    await TestUser().query().where('id', 1).orWhereRaw('age < ?', [10]).get();

    expect(dbSpy.lastSql, contains('WHERE "id" = ? OR age < ?'));
    expect(dbSpy.lastArgs, [1, 10]);
  });

  test('It handles whereExists (Subqueries)', () async {
    final subQuery = QueryBuilder<TestUser>(
      'posts',
      (map) => TestUser(map),
    ).whereRaw('user_id = users.id').where('active', 1).select(['1']);

    await TestUser().query().whereExists(subQuery).get();

    expect(
      dbSpy.lastSql,
      contains(
        'WHERE EXISTS (SELECT "1" FROM "posts" WHERE user_id = users.id AND "active" = ?)',
      ),
    );

    expect(dbSpy.lastArgs, [1]);
  });

  test('It handles whereNotExists', () async {
    final subQuery = QueryBuilder<TestUser>(
      'posts',
      (map) => TestUser(map),
    ).select(['1']);

    await TestUser().query().whereNotExists(subQuery).get();

    expect(dbSpy.lastSql, contains('WHERE NOT EXISTS (SELECT "1" FROM "posts")'));
  });

  test('It handles orWhereIn', () async {
    await TestUser().query().where('id', 1).orWhereIn('role', [
      'admin',
      'editor',
    ]).get();

    expect(dbSpy.lastSql, contains('WHERE "id" = ? OR "role" IN (?, ?)'));
    expect(dbSpy.lastArgs, [1, 'admin', 'editor']);
  });

  test('It handles select() projection', () async {
    await TestUser().query().select(['name', 'email']).get();

    expect(dbSpy.lastSql, startsWith('SELECT "name", "email" FROM "users"'));
  });

  test('It handles offset()', () async {
    await TestUser().query().limit(10).offset(5).get();

    expect(dbSpy.lastSql, contains('LIMIT 10'));
    expect(dbSpy.lastSql, contains('OFFSET 5'));
  });

  test('findOrFail() returns model if found', () async {
    final foundMock = MockDatabaseSpy([], {
      'LIMIT 1': [
        {'id': 1, 'name': 'David'},
      ],
    });
    DatabaseManager().setDatabase(foundMock);

    final user = await TestUser().query().findOrFail(1);
    expect(user.id, 1);
  });

  test('Aggregate functions generate correct SQL', () async {
    final countMock = MockDatabaseSpy([], {
      'SELECT COUNT(*) as aggregate': [
        {'aggregate': 42},
      ],
    });
    DatabaseManager().setDatabase(countMock);

    final count = await TestUser().where('active', 1).count();

    expect(count, 42);
    expect(
      countMock.lastSql,
      contains('SELECT COUNT(*) as aggregate FROM "users"'),
    );
    expect(countMock.lastSql, contains('WHERE "active" = ?'));

    final sumMock = MockDatabaseSpy([], {
      'SELECT SUM(price) as aggregate': [
        {'aggregate': 100.50},
      ],
    });
    DatabaseManager().setDatabase(sumMock);

    final total = await TestUser().query().sum('price');
    expect(total, 100.50);
    expect(sumMock.lastSql, contains('SELECT SUM(price) as aggregate'));

    final existsMock = MockDatabaseSpy([], {
      'LIMIT 1': [
        {'id': 1},
      ],
    });
    DatabaseManager().setDatabase(existsMock);

    final exists = await TestUser().where('id', 1).exists();
    expect(exists, isTrue);
    expect(existsMock.lastSql, contains('LIMIT 1'));
  });

  test('cast() preserves ALL query state and bindings', () async {
    final dbSpy = MockDatabaseSpy([], {
      'FROM "users"': [
        {'id': 1, 'name': 'SuperAdmin', 'role': 'admin'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);

    final originalQuery = TestUser()
        .query()
        .select(['name', 'role'])
        .join('roles', 'users.role_id', '=', 'roles.id')
        .where('active', 1)
        .whereRaw('age > ?', bindings: [21])
        .orderBy('created_at', direction: 'DESC')
        .limit(10)
        .offset(5);

    final castedQuery = originalQuery.cast<AdminView>(AdminView.new);

    final results = await castedQuery.get();

    expect(results, isA<List<AdminView>>());
    expect(results.first, isA<AdminView>());

    final sql = dbSpy.lastSql;

    expect(sql, startsWith('SELECT "users"."name", "users"."role" FROM "users"'));
    expect(sql, contains('JOIN "roles" ON "users"."role_id" = "roles"."id"'));
    expect(sql, contains('WHERE "active" = ? AND age > ?'));
    expect(sql, contains('ORDER BY "created_at" DESC'));
    expect(sql, contains('LIMIT 10'));
    expect(sql, contains('OFFSET 5'));
    expect(dbSpy.lastArgs, equals([1, 21]));
  });

  test('cast() copies eager loading (_with) configuration', () async {
    final dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);

    final originalQuery = TestUser().query().withRelations(['posts']);
    final castedQuery = originalQuery.cast<AdminView>(AdminView.new);

    expect(castedQuery, isNotNull);
  });
}


--- FILE: test/core/lifecycle_hooks_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class HookUser extends Model {
  @override
  String get table => 'users';

  bool allowSave = true;
  bool allowDelete = true;

  List<String> hookOrder = [];

  bool onSavingCalled = false;
  bool onSavedCalled = false;
  bool onDeletingCalled = false;
  bool onDeletedCalled = false;

  HookUser([super.attributes]);

  @override
  HookUser fromMap(Map<String, dynamic> map) => HookUser(map);

  @override
  Future<bool> onSaving() async {
    hookOrder.add('onSaving');
    onSavingCalled = true;
    return allowSave;
  }

  @override
  Future<void> onSaved() async {
    hookOrder.add('onSaved');
    onSavedCalled = true;
  }

  @override
  Future<bool> onDeleting() async {
    hookOrder.add('onDeleting');
    onDeletingCalled = true;
    return allowDelete;
  }

  @override
  Future<void> onDeleted() async {
    hookOrder.add('onDeleted');
    onDeletedCalled = true;
  }
}

class ModifyingHookUser extends Model {
  @override
  String get table => 'users';

  ModifyingHookUser([super.attributes]);

  @override
  ModifyingHookUser fromMap(Map<String, dynamic> map) => ModifyingHookUser(map);

  @override
  Future<bool> onSaving() async {
    // Modify attributes before save
    attributes['modified_by_hook'] = true;
    attributes['slug'] = (attributes['name'] as String?)
        ?.toLowerCase()
        .replaceAll(' ', '-');
    return true;
  }
}

class AsyncHookUser extends Model {
  @override
  String get table => 'users';

  List<String> asyncOrder = [];

  AsyncHookUser([super.attributes]);

  @override
  AsyncHookUser fromMap(Map<String, dynamic> map) => AsyncHookUser(map);

  @override
  Future<bool> onSaving() async {
    await Future.delayed(const Duration(milliseconds: 10));
    asyncOrder.add('onSaving_complete');
    return true;
  }

  @override
  Future<void> onSaved() async {
    await Future.delayed(const Duration(milliseconds: 10));
    asyncOrder.add('onSaved_complete');
  }
}

class ThrowingHookUser extends Model {
  @override
  String get table => 'users';
  ThrowingHookUser([super.attributes]);
  @override
  ThrowingHookUser fromMap(Map<String, dynamic> map) => ThrowingHookUser(map);

  @override
  Future<bool> onSaving() async {
    throw Exception('Error in onSaving');
  }
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'last_insert_row_id': [
        {'id': 1},
      ],
      'FROM users': [
        {'id': 1, 'name': 'David'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Lifecycle Hooks - Save', () {
    test('onSaving returns false cancels insert', () async {
      final user = HookUser({'name': 'David'});
      user.allowSave = false;

      await user.save();

      expect(dbSpy.history, isEmpty);
      expect(user.onSavingCalled, isTrue);
      expect(user.onSavedCalled, isFalse);
    });

    test('onSaving returns false cancels update', () async {
      final user = HookUser({'id': 1, 'name': 'David'});
      user.exists = true;
      user.syncOriginal();
      user.allowSave = false;

      user.attributes['name'] = 'Updated';
      await user.save();

      expect(dbSpy.history, isEmpty);
    });

    test('onSaving can modify attributes before save', () async {
      final mockDb = MockDatabaseSpy([], {
        'last_insert_row_id': [
          {'id': 1},
        ],
        'FROM users': [
          {
            'id': 1,
            'name': 'Test User',
            'modified_by_hook': true,
            'slug': 'test-user',
          },
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = ModifyingHookUser({'name': 'Test User'});
      await user.save();

      final insertSql = mockDb.history.firstWhere(
        (s) => s.contains('INSERT'),
        orElse: () => '',
      );
      expect(insertSql, contains('modified_by_hook'));
      expect(insertSql, contains('slug'));
      expect(user.attributes['modified_by_hook'], isTrue);
      expect(user.attributes['slug'], 'test-user');
    });

    test('onSaved called after successful insert', () async {
      final user = HookUser({'name': 'David'});
      await user.save();

      expect(user.onSavingCalled, isTrue);
      expect(user.onSavedCalled, isTrue);
    });

    test('onSaved called after successful update', () async {
      final user = HookUser({'id': 1, 'name': 'David'});
      user.exists = true;
      user.syncOriginal();

      user.attributes['name'] = 'Updated';
      await user.save();

      expect(user.onSavedCalled, isTrue);
    });

    test('onSaved not called if onSaving returns false', () async {
      final user = HookUser({'name': 'David'});
      user.allowSave = false;

      await user.save();

      expect(user.onSavingCalled, isTrue);
      expect(user.onSavedCalled, isFalse);
    });
  });

  group('Lifecycle Hooks - Delete', () {
    test('onDeleting returns false cancels delete', () async {
      final user = HookUser({'id': 1});
      user.exists = true;
      user.allowDelete = false;

      await user.delete();

      expect(dbSpy.history, isEmpty);
      expect(user.onDeletingCalled, isTrue);
      expect(user.onDeletedCalled, isFalse);
    });

    test('onDeleted called after successful delete', () async {
      final user = HookUser({'id': 1});
      user.exists = true;

      await user.delete();

      expect(user.onDeletingCalled, isTrue);
      expect(user.onDeletedCalled, isTrue);
    });

    test('onDeleted not called if onDeleting returns false', () async {
      final user = HookUser({'id': 1});
      user.exists = true;
      user.allowDelete = false;

      await user.delete();

      expect(user.onDeletingCalled, isTrue);
      expect(user.onDeletedCalled, isFalse);
    });
  });

  group('Lifecycle Hooks - Order & Async', () {
    test('hooks called in correct order', () async {
      final user = HookUser({'name': 'David'});
      await user.save();

      expect(user.hookOrder, ['onSaving', 'onSaved']);
    });

    test('delete hooks called in correct order', () async {
      final user = HookUser({'id': 1});
      user.exists = true;

      await user.delete();

      expect(user.hookOrder, ['onDeleting', 'onDeleted']);
    });

    test('async hooks properly awaited', () async {
      final user = AsyncHookUser({'name': 'David'});
      await user.save();

      expect(user.asyncOrder, ['onSaving_complete', 'onSaved_complete']);
    });
  });

  test(
    'save() propagates exception from onSaving and prevents DB operation',
    () async {
      final user = ThrowingHookUser({'name': 'David'});

      try {
        await user.save();
        fail('Should have thrown Exception');
      } catch (e) {
        expect(e.toString(), contains('Error in onSaving'));
      }

      expect(dbSpy.history, isEmpty);
      expect(user.exists, isFalse);
    },
  );
}


--- FILE: test/core/model_crud_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'last_insert_row_id': [
        {'id': 1},
      ],
      'FROM users': [
        {'id': 1, 'name': 'David', 'email': 'david@test.com'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Create Operations', () {
    test('save() new model without any attributes', () async {
      final user = User();
      await user.save();

      expect(dbSpy.history.any((s) => s.contains('INSERT INTO users')), isTrue);
      expect(user.exists, isTrue);
    });

    test('save() with pre-set id (no auto-increment)', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 'custom-uuid-123', 'name': 'David'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = User({'id': 'custom-uuid-123', 'name': 'David'});
      await user.save();

      final insertSql = mockDb.history.firstWhere((s) => s.contains('INSERT'));
      expect(insertSql, contains('id'));

      expect(user.id, 'custom-uuid-123');
    });

    test('save() preserves attribute types after refresh', () async {
      final mockDb = MockDatabaseSpy([], {
        'last_insert_row_id': [
          {'id': 1},
        ],
        'FROM users': [
          {'id': 1, 'name': 'David', 'age': 30, 'active': 1},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = User({'name': 'David', 'age': 30, 'active': 1});
      await user.save();

      expect(user.attributes['age'], 30);
      expect(user.attributes['active'], 1);
    });

    test('save() with special characters in string values', () async {
      final user = User({
        'name': "O'Connor",
        'bio': 'Line1\nLine2\tTabbed',
        'emoji': 'ðŸ‘ðŸŽ‰',
      });

      expect(user.attributes['name'], "O'Connor");
      expect(user.attributes['bio'], 'Line1\nLine2\tTabbed');
      expect(user.attributes['emoji'], 'ðŸ‘ðŸŽ‰');

      await user.save();

      expect(dbSpy.history.any((s) => s.contains('INSERT')), isTrue);
    });

    test('save() with very long text values', () async {
      final longText = 'A' * 10000;
      final user = User({'bio': longText});

      expect(user.attributes['bio'], longText);
      expect(user.attributes['bio'].length, 10000);

      await user.save();

      expect(dbSpy.history.any((s) => s.contains('INSERT')), isTrue);
    });
  });

  group('Update Operations', () {
    test('save() updates only changed attributes', () async {
      final user = User({
        'id': 1,
        'name': 'David',
        'email': 'david@test.com',
        'age': 30,
      });
      user.exists = true;
      user.syncOriginal();

      user.attributes['email'] = 'new@test.com';

      await user.save();

      final updateSql = dbSpy.history.firstWhere(
        (s) => s.contains('UPDATE'),
        orElse: () => '',
      );
      expect(updateSql, contains('"email" = ?'));
      expect(updateSql, isNot(contains('"name" = ?')));
      expect(updateSql, isNot(contains('"age" = ?')));
    });

    test(
      'save() with unchanged attributes does nothing and returns early',
      () async {
        final user = User({'id': 1, 'name': 'David'});
        user.exists = true;
        user.syncOriginal();

        await user.save();

        expect(dbSpy.history, isEmpty);
      },
    );

    test('save() resets dirty state after success', () async {
      final user = User({'id': 1, 'name': 'David'});
      user.exists = true;
      user.syncOriginal();

      user.attributes['name'] = 'Updated';
      await user.save();

      expect(user.original['name'], user.attributes['name']);
    });

    test('save() with null value overwrites existing', () async {
      final user = User({'id': 1, 'name': 'David', 'email': 'test@test.com'});
      user.exists = true;
      user.syncOriginal();

      user.attributes['email'] = null;
      await user.save();

      final updateSql = dbSpy.history.firstWhere(
        (s) => s.contains('UPDATE'),
        orElse: () => '',
      );
      expect(updateSql, contains('"email" = ?'));
    });

    test('save() detects changes correctly with different types', () async {
      final user = User({'id': 1, 'count': 5, 'active': true});
      user.exists = true;
      user.syncOriginal();

      user.attributes['count'] = 10;
      user.attributes['active'] = false;
      await user.save();

      final updateSql = dbSpy.history.firstWhere(
        (s) => s.contains('UPDATE'),
        orElse: () => '',
      );
      expect(updateSql, contains('"count" = ?'));
      expect(updateSql, contains('"active" = ?'));
    });
  });

  group('Delete Operations', () {
    test('delete() on model without id does nothing', () async {
      final user = User({'name': 'David'});
      await user.delete();
      expect(dbSpy.history, isEmpty);
    });

    test('delete() executes DELETE statement', () async {
      final user = User({'id': 50});
      user.exists = true;

      await user.delete();

      expect(dbSpy.lastSql, contains('DELETE FROM "users"'));
      expect(dbSpy.lastSql, contains('WHERE "id" = ?'));
      expect(dbSpy.lastArgs, [50]);
    });
  });

  group('Refresh & Sync Operations', () {
    test('syncOriginal() creates deep copy', () async {
      final user = User({
        'id': 1,
        'name': 'David',
        'tags': ['a', 'b'],
      });
      user.syncOriginal();

      user.attributes['name'] = 'Changed';

      expect(user.original['name'], 'David');
      expect(user.attributes['name'], 'Changed');
    });

    test('syncOriginal() after save reflects DB values', () async {
      final mockDb = MockDatabaseSpy([], {
        'last_insert_row_id': [
          {'id': 99},
        ],
        'FROM users': [
          {'id': 99, 'name': 'FromDB', 'created_at': '2024-01-01'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = User({'name': 'Original'});
      await user.save();

      expect(user.original['name'], 'FromDB');
      expect(user.original['created_at'], '2024-01-01');
    });

    test('attributes modification does not affect original', () async {
      final user = User({'id': 1, 'name': 'David'});
      user.syncOriginal();

      user.attributes['name'] = 'Modified';
      user.attributes['newField'] = 'value';

      expect(user.original['name'], 'David');
      expect(user.original.containsKey('newField'), isFalse);
    });
  });

  test('syncOriginal fails on nested mutable objects (List/Map)', () async {
    final tags = ['a', 'b'];
    final user = User({'id': 1, 'tags': tags});
    user.syncOriginal();

    (user.attributes['tags'] as List).add('c');

    expect(user.original['tags'], equals(['a', 'b']));
  });

  test(
    'syncOriginal performs true DEEP COPY on nested mutable objects',
    () async {
      final initialTags = ['flutter', 'dart'];
      final settings = {'theme': 'dark'};

      final user = User({
        'name': 'David',
        'tags': initialTags,
        'settings': settings,
      });

      user.syncOriginal();

      (user.attributes['tags'] as List).add('orm');
      (user.attributes['settings'] as Map)['theme'] = 'light';

      expect(user.original['tags'], equals(['flutter', 'dart']));
      expect(user.original['settings'], equals({'theme': 'dark'}));

      expect(user.attributes['tags'], contains('orm'));
    },
  );
}


--- FILE: test/core/watch_test.dart ---
import 'dart:async';
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class WatchUser extends Model {
  @override
  String get table => 'users';

  WatchUser([super.attributes]);

  @override
  WatchUser fromMap(Map<String, dynamic> map) => WatchUser(map);
}

class StreamingMockDatabase extends MockDatabaseSpy {
  final StreamController<List<Map<String, dynamic>>> _controller =
      StreamController.broadcast();

  StreamingMockDatabase() : super();

  void emit(List<Map<String, dynamic>> data) {
    _controller.add(data);
  }

  @override
  Stream<List<Map<String, dynamic>>> watch(
    String sql, {
    List<dynamic>? parameters,
  }) {
    lastSql = sql;
    lastArgs = parameters;
    return _controller.stream;
  }

  void dispose() {
    _controller.close();
  }
}

void main() {
  group('Watch/Stream Tests', () {
    test('watch() returns stream of typed models', () async {
      final mockDb = MockDatabaseSpy([
        {'id': 1, 'name': 'David'},
        {'id': 2, 'name': 'Romolo'},
      ]);
      DatabaseManager().setDatabase(mockDb);

      final stream = WatchUser().query().watch();

      expect(stream, isA<Stream<List<WatchUser>>>());
    });

    test('watch() applies where clauses', () async {
      final mockDb = MockDatabaseSpy([]);
      DatabaseManager().setDatabase(mockDb);

      final query = WatchUser().query().where('active', 1);
      final sql = query.toSql();

      expect(sql, contains('WHERE "active" = ?'));
    });

    test('watch() hydrates models correctly', () async {
      final mockDb = MockDatabaseSpy([
        {'id': 1, 'name': 'David'},
      ]);
      DatabaseManager().setDatabase(mockDb);

      final stream = WatchUser().query().watch();
      final users = await stream.first;

      expect(users.first, isA<WatchUser>());
      expect(users.first.attributes['name'], 'David');
      expect(users.first.exists, isTrue);
    });

    test('watch() stream emits on data change', () async {
      final streamingDb = StreamingMockDatabase();
      DatabaseManager().setDatabase(streamingDb);

      final stream = WatchUser().query().watch();
      final results = <List<WatchUser>>[];

      final subscription = stream.listen((users) {
        results.add(users);
      });

      // Emit first batch
      streamingDb.emit([
        {'id': 1, 'name': 'David'},
      ]);

      await Future.delayed(const Duration(milliseconds: 50));

      // Emit second batch
      streamingDb.emit([
        {'id': 1, 'name': 'David'},
        {'id': 2, 'name': 'Romolo'},
      ]);

      await Future.delayed(const Duration(milliseconds: 50));

      expect(results.length, 2);
      expect(results[0].length, 1);
      expect(results[1].length, 2);

      await subscription.cancel();
      streamingDb.dispose();
    });

    test('watch() can be cancelled', () async {
      final streamingDb = StreamingMockDatabase();
      DatabaseManager().setDatabase(streamingDb);

      final stream = WatchUser().query().watch();
      var emitCount = 0;

      final subscription = stream.listen((_) {
        emitCount++;
      });

      streamingDb.emit([
        {'id': 1},
      ]);
      await Future.delayed(const Duration(milliseconds: 10));

      await subscription.cancel();

      streamingDb.emit([
        {'id': 2},
      ]); // Should not be received
      await Future.delayed(const Duration(milliseconds: 10));

      expect(emitCount, 1);
      streamingDb.dispose();
    });
  });
}


--- FILE: test/core/group_by_having_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Order extends Model {
  @override
  String get table => 'orders';

  Order([super.attributes]);

  @override
  Order fromMap(Map<String, dynamic> map) => Order(map);
}

class Product extends Model {
  @override
  String get table => 'products';

  Product([super.attributes]);

  @override
  Product fromMap(Map<String, dynamic> map) => Product(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('GROUP BY Clause', () {
    test('groupBy() generates correct SQL', () async {
      await Order()
          .query()
          .select(['customer_id', 'COUNT(*) as order_count'])
          .groupBy(['customer_id'])
          .get();

      expect(dbSpy.lastSql, contains('GROUP BY "customer_id"'));
    });

    test('groupBy() accepts multiple columns', () async {
      await Order()
          .query()
          .select(['customer_id', 'status', 'COUNT(*) as count'])
          .groupBy(['customer_id', 'status'])
          .get();

      expect(dbSpy.lastSql, contains('GROUP BY "customer_id", "status"'));
    });

    test('groupByColumn() is convenience for single column', () async {
      await Order()
          .query()
          .select(['status', 'COUNT(*) as count'])
          .groupByColumn('status')
          .get();

      expect(dbSpy.lastSql, contains('GROUP BY "status"'));
    });

    test('groupBy() validates column identifiers', () async {
      expect(
        () => Order().query().groupBy(['status; DROP TABLE orders']),
        throwsA(isA<InvalidQueryException>()),
      );
    });

    test('groupBy() works with dotted identifiers', () async {
      await Order()
          .query()
          .select(['orders.customer_id', 'COUNT(*) as count'])
          .groupBy(['orders.customer_id'])
          .get();

      expect(dbSpy.lastSql, contains('GROUP BY "orders"."customer_id"'));
    });
  });

  group('HAVING Clause', () {
    test('having() generates correct SQL', () async {
      await Order()
          .query()
          .select(['customer_id', 'SUM(total) as total_spent'])
          .groupBy(['customer_id'])
          .having('SUM(total)', 1000, operator: '>')
          .get();

      expect(dbSpy.lastSql, contains('GROUP BY "customer_id"'));
      expect(dbSpy.lastSql, contains('HAVING SUM(total) > ?'));
      expect(dbSpy.lastArgs, contains(1000));
    });

    test('having() supports multiple conditions with AND', () async {
      await Order()
          .query()
          .select(['customer_id', 'COUNT(*) as order_count'])
          .groupBy(['customer_id'])
          .having('COUNT(*)', 5, operator: '>=')
          .having('SUM(total)', 100, operator: '>')
          .get();

      expect(
        dbSpy.lastSql,
        contains('HAVING COUNT(*) >= ? AND SUM(total) > ?'),
      );
      expect(dbSpy.lastArgs, equals([5, 100]));
    });

    test('orHaving() generates OR condition', () async {
      await Order()
          .query()
          .select(['customer_id', 'COUNT(*) as order_count'])
          .groupBy(['customer_id'])
          .having('COUNT(*)', 10, operator: '>=')
          .orHaving('SUM(total)', 5000, operator: '>')
          .get();

      expect(dbSpy.lastSql, contains('HAVING COUNT(*) >= ? OR SUM(total) > ?'));
    });

    test('havingRaw() allows complex expressions', () async {
      await Product()
          .query()
          .select(['category', 'AVG(price) as avg_price'])
          .groupBy(['category'])
          .havingRaw('AVG(price) > ? AND COUNT(*) >= ?', bindings: [50.0, 10])
          .get();

      expect(
        dbSpy.lastSql,
        contains('HAVING AVG(price) > ? AND COUNT(*) >= ?'),
      );
      expect(dbSpy.lastArgs, equals([50.0, 10]));
    });

    test('havingBetween() generates BETWEEN clause', () async {
      await Order()
          .query()
          .select(['customer_id', 'COUNT(*) as order_count'])
          .groupBy(['customer_id'])
          .havingBetween('COUNT(*)', 5, 20)
          .get();

      expect(dbSpy.lastSql, contains('HAVING COUNT(*) BETWEEN ? AND ?'));
      expect(dbSpy.lastArgs, equals([5, 20]));
    });

    test('havingNull() and havingNotNull() work correctly', () async {
      await Order()
          .query()
          .select(['customer_id', 'MAX(discount) as max_discount'])
          .groupBy(['customer_id'])
          .havingNotNull('MAX(discount)')
          .get();

      expect(dbSpy.lastSql, contains('HAVING MAX(discount) IS NOT NULL'));
    });

    test('having() validates operators', () async {
      expect(
        () => Order()
            .query()
            .groupBy(['customer_id'])
            .having('COUNT(*)', 5, operator: 'INVALID'),
        throwsA(isA<InvalidQueryException>()),
      );
    });
  });

  group('GROUP BY + HAVING Integration', () {
    test('full query with WHERE, GROUP BY, HAVING, ORDER BY', () async {
      await Order()
          .query()
          .select([
            'customer_id',
            'COUNT(*) as order_count',
            'SUM(total) as total_spent',
          ])
          .where('status', 'completed')
          .groupBy(['customer_id'])
          .having('COUNT(*)', 3, operator: '>=')
          .orderBy('total_spent', direction: 'DESC')
          .limit(10)
          .get();

      final sql = dbSpy.lastSql;

      expect(sql, contains('WHERE "status" = ?'));
      expect(sql, contains('GROUP BY "customer_id"'));
      expect(sql, contains('HAVING COUNT(*) >= ?'));
      expect(sql, contains('ORDER BY "total_spent" DESC'));
      expect(sql, contains('LIMIT 10'));

      // Verify WHERE comes before GROUP BY
      expect(sql.indexOf('WHERE'), lessThan(sql.indexOf('GROUP BY')));
      // Verify GROUP BY comes before HAVING
      expect(sql.indexOf('GROUP BY'), lessThan(sql.indexOf('HAVING')));
      // Verify HAVING comes before ORDER BY
      expect(sql.indexOf('HAVING'), lessThan(sql.indexOf('ORDER BY')));
    });

    test(
      'bindings are in correct order (WHERE bindings then HAVING bindings)',
      () async {
        await Order()
            .query()
            .select(['customer_id', 'COUNT(*) as count'])
            .where('status', 'active')
            .where('created_at', '2024-01-01', '>')
            .groupBy(['customer_id'])
            .having('COUNT(*)', 5, operator: '>=')
            .having('SUM(total)', 1000, operator: '>')
            .get();

        expect(dbSpy.lastArgs, equals(['active', '2024-01-01', 5, 1000]));
      },
    );

    test('cast() preserves GROUP BY and HAVING state', () async {
      final original = Order()
          .query()
          .select(['customer_id', 'COUNT(*) as count'])
          .groupBy(['customer_id'])
          .having('COUNT(*)', 5, operator: '>=');

      final casted = original.cast<Order>(Order.new);
      await casted.get();

      expect(dbSpy.lastSql, contains('GROUP BY "customer_id"'));
      expect(dbSpy.lastSql, contains('HAVING COUNT(*) >= ?'));
    });
  });

  group('Aggregates with GROUP BY', () {
    test('count() calculates total groups using subquery wrapper', () async {
      final countMock = MockDatabaseSpy([], {
        'SELECT COUNT(*) as aggregate': [
          {'aggregate': 5},
        ],
      });
      DatabaseManager().setDatabase(countMock);

      final count = await Order().query().groupBy(['status']).count();

      expect(count, 5);

      final sql = countMock.lastSql;
      expect(sql, startsWith('SELECT COUNT(*) as aggregate FROM ('));
      expect(sql, contains('SELECT "orders".* FROM "orders"'));
      expect(sql, contains('GROUP BY "status"'));
      expect(sql, endsWith(') as temp_table'));
    });

    test('sum() throws QueryException when used with groupBy', () async {
      expect(
        () => Order().query().groupBy(['customer_id']).sum('total'),
        throwsA(isA<QueryException>()),
      );
    });

    test('avg() throws QueryException when used with groupBy', () async {
      expect(
        () => Order().query().groupBy(['customer_id']).avg('score'),
        throwsA(isA<QueryException>()),
      );
    });

    test('min() throws QueryException when used with groupBy', () async {
      expect(
        () => Order().query().groupBy(['customer_id']).min('total'),
        throwsA(isA<QueryException>()),
      );
    });

    test('max() throws QueryException when used with groupBy', () async {
      expect(
        () => Order().query().groupBy(['customer_id']).max('total'),
        throwsA(isA<QueryException>()),
      );
    });
  });
}


--- FILE: test/core/query_builder_validation_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class TestUser extends Model {
  @override
  String get table => 'users';

  TestUser([super.attributes]);

  @override
  TestUser fromMap(Map<String, dynamic> map) => TestUser(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('WHERE Clauses - Extended', () {
    test('where() with null value generates IS NULL', () async {
      await TestUser().query().where('deleted_at', null).get();

      expect(dbSpy.lastSql, contains('"deleted_at" IS NULL'));
    });

    test('where() with empty string', () async {
      await TestUser().query().where('name', '').get();

      expect(dbSpy.lastSql, contains('"name" = ?'));
      expect(dbSpy.lastArgs, contains(''));
    });

    test('whereIn() with empty list generates 0 = 1', () async {
      await TestUser().query().whereIn('id', []).get();

      expect(dbSpy.lastSql, contains('0 = 1'));
      expect(dbSpy.lastArgs, isEmpty);
    });

    test('whereIn() with single item', () async {
      await TestUser().query().whereIn('id', [42]).get();

      expect(dbSpy.lastSql, contains('"id" IN (?)'));
      expect(dbSpy.lastArgs, equals([42]));
    });

    test('whereIn() with duplicate values', () async {
      await TestUser().query().whereIn('id', [1, 1, 2, 2, 3]).get();

      expect(dbSpy.lastSql, contains('"id" IN (?, ?, ?, ?, ?)'));
      expect(dbSpy.lastArgs, equals([1, 1, 2, 2, 3]));
    });

    test('orWhereNull() generates correct SQL', () async {
      await TestUser()
          .query()
          .where('active', 1)
          .orWhereNull('deleted_at')
          .get();

      expect(dbSpy.lastSql, contains('WHERE "active" = ? OR "deleted_at" IS NULL'));
    });

    test('orWhereNotNull() generates correct SQL', () async {
      await TestUser()
          .query()
          .where('active', 0)
          .orWhereNotNull('verified_at')
          .get();

      expect(
        dbSpy.lastSql,
        contains('WHERE "active" = ? OR "verified_at" IS NOT NULL'),
      );
    });

    test('where with LIKE operator and wildcards', () async {
      await TestUser().query().where('name', '%David%', 'LIKE').get();

      expect(dbSpy.lastSql, contains('"name" LIKE ?'));
      expect(dbSpy.lastArgs, contains('%David%'));
    });

    test('where with NOT LIKE operator', () async {
      await TestUser()
          .query()
          .where('email', '%spam%', 'NOT LIKE')
          .get();

      expect(dbSpy.lastSql, contains('"email" NOT LIKE ?'));
      expect(dbSpy.lastArgs, contains('%spam%'));
    });

    test('multiple chained where clauses with mixed operators', () async {
      await TestUser()
          .query()
          .where('age', 18, '>=')
          .where('age', 65, '<=')
          .where('status', 'active')
          .orWhere('role', 'admin')
          .get();

      expect(
        dbSpy.lastSql,
        contains('WHERE "age" >= ? AND "age" <= ? AND "status" = ? OR "role" = ?'),
      );
      expect(dbSpy.lastArgs, equals([18, 65, 'active', 'admin']));
    });

    test('It handles nested where groups (parentheses)', () async {
      await TestUser().query().where('status', 'active').whereGroup((q) {
        q.where('role', 'admin').orWhere('role', 'editor');
      }).get();

      expect(
        dbSpy.lastSql,
        contains('WHERE "status" = ? AND ("role" = ? OR "role" = ?)'),
      );
      expect(dbSpy.lastArgs, ['active', 'admin', 'editor']);
    });

    test('It handles nested OR groups with correct binding order', () async {
      await TestUser().query().where('age', 18, '>').orWhereGroup((
        q,
      ) {
        q
            .where('status', 'pending')
            .where('created_at', '2023-01-01', '>');
      }).get();

      expect(
        dbSpy.lastSql,
        contains('WHERE "age" > ? OR ("status" = ? AND "created_at" > ?)'),
      );
      expect(dbSpy.lastArgs, [18, 'pending', '2023-01-01']);
    });

    test('It supports deep nesting', () async {
      await TestUser().query().where('a', 1).whereGroup((q1) {
        q1.where('b', 2).orWhereGroup((q2) {
          q2.where('c', 3).where('d', 4);
        });
      }).get();

      expect(
        dbSpy.lastSql,
        contains('WHERE "a" = ? AND ("b" = ? OR ("c" = ? AND "d" = ?))'),
      );
      expect(dbSpy.lastArgs, [1, 2, 3, 4]);
    });
  });

  group('Aggregates - Extended', () {
    test('count() with column name', () async {
      final countMock = MockDatabaseSpy([], {
        'SELECT COUNT(email) as aggregate': [
          {'aggregate': 50},
        ],
      });
      DatabaseManager().setDatabase(countMock);

      final count = await TestUser().query().count('email');

      expect(count, 50);
      expect(countMock.lastSql, contains('COUNT(email)'));
    });

    test('count() with WHERE clause', () async {
      final countMock = MockDatabaseSpy([], {
        'SELECT COUNT(*) as aggregate': [
          {'aggregate': 10},
        ],
      });
      DatabaseManager().setDatabase(countMock);

      final count = await TestUser().query().where('active', 1).count();

      expect(count, 10);
      expect(countMock.lastSql, contains('WHERE "active" = ?'));
    });

    test('sum() returns 0 for empty result', () async {
      final sumMock = MockDatabaseSpy([], {
        'SELECT SUM(amount) as aggregate': [
          {'aggregate': null},
        ],
      });
      DatabaseManager().setDatabase(sumMock);

      final sum = await TestUser().query().sum('amount');

      expect(sum, 0);
    });

    test('sum() with null values in column', () async {
      final sumMock = MockDatabaseSpy([], {
        'SELECT SUM(score) as aggregate': [
          {'aggregate': 150},
        ],
      });
      DatabaseManager().setDatabase(sumMock);

      final sum = await TestUser().query().sum('score');

      expect(sum, 150);
    });

    test('avg() with empty result returns null', () async {
      final avgMock = MockDatabaseSpy([], {
        'SELECT AVG(rating) as aggregate': [
          {'aggregate': null},
        ],
      });
      DatabaseManager().setDatabase(avgMock);

      final avg = await TestUser().query().avg('rating');

      expect(avg, null);
    });

    test('avg() with integer column', () async {
      final avgMock = MockDatabaseSpy([], {
        'SELECT AVG(age) as aggregate': [
          {'aggregate': 35},
        ],
      });
      DatabaseManager().setDatabase(avgMock);

      final avg = await TestUser().query().avg('age');

      expect(avg, 35.0);
      expect(avg, isA<double>());
    });

    test('min() with empty result', () async {
      final minMock = MockDatabaseSpy([], {
        'SELECT MIN(price) as aggregate': [
          {'aggregate': null},
        ],
      });
      DatabaseManager().setDatabase(minMock);

      final min = await TestUser().query().min('price');

      expect(min, isNull);
    });

    test('max() with empty result', () async {
      final maxMock = MockDatabaseSpy([], {
        'SELECT MAX(score) as aggregate': [
          {'aggregate': null},
        ],
      });
      DatabaseManager().setDatabase(maxMock);

      final max = await TestUser().query().max('score');

      expect(max, isNull);
    });

    test('min() with datetime column', () async {
      final minMock = MockDatabaseSpy([], {
        'SELECT MIN(created_at) as aggregate': [
          {'aggregate': '2020-01-01T00:00:00.000'},
        ],
      });
      DatabaseManager().setDatabase(minMock);

      final min = await TestUser().query().min('created_at');

      expect(min, '2020-01-01T00:00:00.000');
    });

    test('max() with string column', () async {
      final maxMock = MockDatabaseSpy([], {
        'SELECT MAX(name) as aggregate': [
          {'aggregate': 'Zoe'},
        ],
      });
      DatabaseManager().setDatabase(maxMock);

      final max = await TestUser().query().max('name');

      expect(max, 'Zoe');
    });
  });

  group('Query Methods - Extended', () {
    test('first() returns null on empty result', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final user = await TestUser().query().first();

      expect(user, isNull);
    });

    test('find() with non-existent id returns null', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final user = await TestUser().query().find(999);

      expect(user, isNull);
    });

    test('find() with string id', () async {
      final mockDb = MockDatabaseSpy([], {
        'LIMIT 1': [
          {'id': 'abc-123', 'name': 'David'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = await TestUser().query().find('abc-123');

      expect(user, isNotNull);
      expect(mockDb.lastArgs, contains('abc-123'));
    });

    test('find() with UUID', () async {
      final uuid = '550e8400-e29b-41d4-a716-446655440000';
      final mockDb = MockDatabaseSpy([], {
        'LIMIT 1': [
          {'id': uuid, 'name': 'David'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = await TestUser().query().find(uuid);

      expect(user, isNotNull);
      expect(mockDb.lastArgs, contains(uuid));
    });

    test('exists() returns false on empty table', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final exists = await TestUser().query().exists();

      expect(exists, isFalse);
    });

    test('notExist() returns true on empty table', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final notExist = await TestUser().query().notExist();

      expect(notExist, isTrue);
    });

    test('toSql() returns complete SQL string', () async {
      final sql = TestUser()
          .query()
          .select(['id', 'name'])
          .where('active', 1)
          .orderBy('name')
          .limit(10)
          .offset(5)
          .toSql();

      expect(sql, contains('SELECT "id", "name" FROM "users"'));
      expect(sql, contains('WHERE "active" = ?'));
      expect(sql, contains('ORDER BY "name" ASC'));
      expect(sql, contains('LIMIT 10'));
      expect(sql, contains('OFFSET 5'));
    });

    test('select() with table prefix (users.name)', () async {
      await TestUser().query().select(['users.id', 'users.name']).get();

      expect(dbSpy.lastSql, contains('SELECT "users"."id", "users"."name"'));
    });

    test('select() with alias (name AS user_name)', () async {
      await TestUser().query().select([
        'id',
        'name AS user_name',
        'email AS contact',
      ]).get();

      expect(
        dbSpy.lastSql,
        contains('SELECT "id", "name" AS "user_name", "email" AS "contact"'),
      );
    });
  });

  group('Joins - Extended', () {
    test('multiple joins in single query', () async {
      await TestUser()
          .query()
          .join('profiles', 'users.id', '=', 'profiles.user_id')
          .join('roles', 'users.role_id', '=', 'roles.id')
          .get();

      expect(
        dbSpy.lastSql,
        contains('JOIN "profiles" ON "users"."id" = "profiles"."user_id"'),
      );
      expect(dbSpy.lastSql, contains('JOIN "roles" ON "users"."role_id" = "roles"."id"'));
    });

    test('join with different operators (>, <, !=)', () async {
      await TestUser()
          .query()
          .join('scores', 'users.min_score', '<', 'scores.value')
          .get();

      expect(
        dbSpy.lastSql,
        contains('JOIN "scores" ON "users"."min_score" < "scores"."value"'),
      );
    });

    test('leftJoin generates LEFT JOIN', () async {
      await TestUser()
          .query()
          .leftJoin('profiles', 'users.id', '=', 'profiles.user_id')
          .get();

      expect(
        dbSpy.lastSql,
        contains('LEFT JOIN "profiles" ON "users"."id" = "profiles"."user_id"'),
      );
    });

    test('rightJoin generates RIGHT JOIN', () async {
      await TestUser()
          .query()
          .rightJoin('profiles', 'users.id', '=', 'profiles.user_id')
          .get();

      expect(
        dbSpy.lastSql,
        contains('RIGHT JOIN "profiles" ON "users"."id" = "profiles"."user_id"'),
      );
    });
  });

  group('Validation & Security', () {
    test('where() rejects invalid column names', () {
      expect(
        () => TestUser().query().where('column; DROP TABLE users', 'value'),
        throwsA(isA<InvalidQueryException>()),
      );
    });

    test('whereIn() rejects invalid column names', () {
      expect(
        () => TestUser().query().whereIn('id; DELETE FROM', [1, 2]),
        throwsA(isA<InvalidQueryException>()),
      );
    });

    test('join() rejects invalid table names', () {
      expect(
        () => TestUser().query().join('users; DROP TABLE', 'a.id', '=', 'b.id'),
        throwsA(isA<InvalidQueryException>()),
      );
    });

    test('join() rejects invalid operators', () {
      expect(
        () => TestUser().query().join(
          'profiles',
          'users.id',
          'INVALID',
          'profiles.user_id',
        ),
        throwsA(isA<InvalidQueryException>()),
      );
    });

    test('orderBy() rejects invalid direction', () {
      expect(
        () => TestUser().query().orderBy('name', direction: 'RANDOM'),
        throwsA(isA<InvalidQueryException>()),
      );
    });

    test('groupBy() rejects invalid column names', () {
      expect(
        () => TestUser().query().groupBy(['status; DROP TABLE']),
        throwsA(isA<InvalidQueryException>()),
      );
    });

    test('having() rejects invalid operators', () {
      expect(
        () => TestUser()
            .query()
            .groupBy(['status'])
            .having('COUNT(*)', 5, operator: 'INJECT'),
        throwsA(isA<InvalidQueryException>()),
      );
    });
  });
}


--- FILE: test/core/typed_query_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class TypedUser extends Model with HasSoftDeletes {
  @override
  String get table => 'users';

  TypedUser([super.attributes]);

  @override
  TypedUser fromMap(Map<String, dynamic> map) => TypedUser(map);
}

class RegularUser extends Model {
  @override
  String get table => 'users';

  RegularUser([super.attributes]);

  @override
  RegularUser fromMap(Map<String, dynamic> map) => RegularUser(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'FROM users': [
        {'id': 1, 'name': 'David'},
        {'id': 2, 'name': 'Romolo'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);
  });

  group('TypedQuery Extension', () {
    test('query() returns QueryBuilder<T> not QueryBuilder<Model>', () async {
      final query = RegularUser().query();

      expect(query, isA<QueryBuilder<RegularUser>>());
    });

    test('query() preserves model query overrides', () async {
      await TypedUser().query().get();

      // SoftDeletes should add WHERE deleted_at IS NULL
      expect(dbSpy.lastSql, contains('"deleted_at" IS NULL'));
    });

    test('query() with SoftDeletes applies scope', () async {
      await TypedUser().query().where('name', 'David').get();

      expect(dbSpy.lastSql, contains('"deleted_at" IS NULL'));
      expect(dbSpy.lastSql, contains('"name" = ?'));
    });

    test('get() returns List<T> with correct type', () async {
      final users = await RegularUser().query().get();

      expect(users, isA<List<RegularUser>>());
      expect(users.first, isA<RegularUser>());
    });

    test('first() returns T? with correct type', () async {
      final user = await RegularUser().query().first();

      expect(user, isA<RegularUser?>());
    });

    test('find() returns T? with correct type', () async {
      final mockDb = MockDatabaseSpy([], {
        'LIMIT 1': [
          {'id': 1, 'name': 'David'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = await RegularUser().query().find(1);

      expect(user, isA<RegularUser?>());
    });

    test('query chain maintains type through all operations', () async {
      final query = RegularUser()
          .query()
          .where('active', 1)
          .orderBy('name')
          .limit(10);

      expect(query, isA<QueryBuilder<RegularUser>>());

      final results = await query.get();
      expect(results, isA<List<RegularUser>>());
    });
  });
}


--- FILE: test/relations/morph_to_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);
}

class Video extends Model {
  @override
  String get table => 'videos';
  Video([super.attributes]);
  @override
  Video fromMap(Map<String, dynamic> map) => Video(map);
}

class Comment extends Model {
  @override
  String get table => 'comments';
  Comment([super.attributes]);
  @override
  Comment fromMap(Map<String, dynamic> map) => Comment(map);

  MorphTo<Model> commentable() {
    return morphToTyped('commentable', {
      'posts': Post.new,
      'videos': Video.new,
    });
  }
}

void main() {
  test('MorphTo eager loads mixed types (Posts and Videos)', () async {
    final mockDb = MockDatabaseSpy([], {
      'FROM posts': [
        {'id': 100, 'title': 'Post A'},
      ],
      'FROM videos': [
        {'id': 200, 'title': 'Video B'},
      ],
    });
    DatabaseManager().setDatabase(mockDb);

    final comments = [
      Comment({'id': 1, 'commentable_type': 'posts', 'commentable_id': 100}),
      Comment({'id': 2, 'commentable_type': 'videos', 'commentable_id': 200}),
    ];

    await comments.first.commentable().match(comments, 'commentable');

    final post = comments[0].relations['commentable'];
    final video = comments[1].relations['commentable'];

    expect(post, isA<Post>());
    expect((post as Post).id, 100);

    expect(video, isA<Video>());
    expect((video as Video).id, 200);
  });

  test('MorphTo lazy loads via getResult()', () async {
    final mockDb = MockDatabaseSpy([], {
      'FROM posts': [
        {'id': 100, 'title': 'Post A'},
      ],
    });
    DatabaseManager().setDatabase(mockDb);

    final comment = Comment({
      'id': 1,
      'commentable_type': 'posts',
      'commentable_id': 100,
    });

    final parent = await comment.commentable().getResult();

    expect(parent, isA<Post>());
    expect((parent as Post).attributes['title'], 'Post A');
  });
}


--- FILE: test/relations/morph_to_many_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);

  MorphToMany<Tag> tags() {
    return morphToMany(Tag.new, 'taggable');
  }
}

class Tag extends Model {
  @override
  String get table => 'tags';
  Tag([super.attributes]);
  @override
  Tag fromMap(Map<String, dynamic> map) => Tag(map);
}

void main() {
  group('MorphToMany Relation', () {
    test('It generates correct SQL JOINs for lazy loading', () async {
      final dbSpy = MockDatabaseSpy();
      DatabaseManager().setDatabase(dbSpy);

      final post = Post({'id': 1});

      await post.tags().get();

      expect(
        dbSpy.lastSql,
        contains('JOIN "taggables" ON "tags"."id" = "taggables"."tag_id"'),
      );

      expect(dbSpy.lastSql, contains('"taggables"."taggable_type" = ?'));

      expect(dbSpy.lastSql, contains('"taggables"."taggable_id" = ?'));

      expect(dbSpy.lastArgs, contains('posts'));
      expect(dbSpy.lastArgs, contains(1));
    });

    test('It eager loads tags via pivot table', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM taggables': [
          {'tag_id': 100, 'taggable_id': 1, 'taggable_type': 'posts'},
          {'tag_id': 101, 'taggable_id': 1, 'taggable_type': 'posts'},
        ],
        'FROM tags': [
          {'id': 100, 'name': 'Tech'},
          {'id': 101, 'name': 'News'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
      ];

      await posts.first.tags().match(posts, 'tags');

      final tags = posts[0].relations['tags'] as List;

      expect(tags, hasLength(2));
      expect(tags.first, isA<Tag>());

      final names = tags.map((t) => (t as Tag).attributes['name']).toList();
      expect(names, containsAll(['Tech', 'News']));
    });
  });
}


--- FILE: test/relations/has_many_through_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Country extends Model {
  @override
  String get table => 'countries';
  Country([super.attributes]);
  @override
  Country fromMap(Map<String, dynamic> map) => Country(map);

  HasManyThrough<Post, User> posts() => hasManyThrough(Post.new, User.new);
}

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('HasManyThrough Extended', () {
    test('returns empty when no intermediate records', () async {
      final mockDb = MockDatabaseSpy([], {'FROM users': [], 'FROM posts': []});
      DatabaseManager().setDatabase(mockDb);

      final countries = [
        Country({'id': 1}),
      ];
      await countries.first.posts().match(countries, 'posts');

      // Usa getRelationList per gestire il caso null
      final posts = countries.first.getRelationList<Post>('posts');
      expect(posts, isEmpty);
    });

    test('returns empty when intermediate exists but no target', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 10, 'country_id': 1},
        ],
        'FROM posts': [],
      });
      DatabaseManager().setDatabase(mockDb);

      final countries = [
        Country({'id': 1}),
      ];
      await countries.first.posts().match(countries, 'posts');

      expect(countries.first.relations['posts'], isEmpty);
    });

    test('eager load with complex chain', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 10, 'country_id': 1},
          {'id': 20, 'country_id': 1},
          {'id': 30, 'country_id': 2},
        ],
        'FROM posts': [
          {'id': 100, 'user_id': 10, 'title': 'Post A'},
          {'id': 101, 'user_id': 10, 'title': 'Post B'},
          {'id': 102, 'user_id': 20, 'title': 'Post C'},
          {'id': 103, 'user_id': 30, 'title': 'Post D'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final countries = [
        Country({'id': 1}),
        Country({'id': 2}),
      ];

      await countries.first.posts().match(countries, 'posts');

      // Country 1 has users 10 and 20, which have posts 100, 101, 102
      final country1Posts = countries[0].relations['posts'] as List;
      expect(country1Posts.length, 3);

      // Country 2 has user 30, which has post 103
      final country2Posts = countries[1].relations['posts'] as List;
      expect(country2Posts.length, 1);
    });

    test('custom first key', () async {
      final country = Country({'id': 1});

      // Using default keys
      await country.posts().get();

      expect(dbSpy.lastSql, contains('"users"."country_id" = ?'));
    });

    test('custom second key', () async {
      final country = Country({'id': 1});

      await country.posts().get();

      expect(dbSpy.lastSql, contains('"posts"."user_id"'));
    });
  });
}


--- FILE: test/relations/has_many_through_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Country extends Model {
  @override
  String get table => 'countries';
  Country([super.attributes]);
  @override
  Country fromMap(Map<String, dynamic> map) => Country(map);

  HasManyThrough<Post, User> posts() {
    return hasManyThrough(Post.new, User.new);
  }
}

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);
}

void main() {
  group('HasManyThrough Relation', () {
    test('It constructs SQL with correct JOINS for lazy loading', () async {
      final dbSpy = MockDatabaseSpy();
      DatabaseManager().setDatabase(dbSpy);

      final country = Country({'id': 1, 'name': 'Italy'});

      await country.posts().get();

      expect(dbSpy.lastSql, contains('SELECT "posts".* FROM "posts"'));
      expect(dbSpy.lastSql, contains('JOIN "users" ON "users"."id" = "posts"."user_id"'));
      expect(dbSpy.lastSql, contains('WHERE "users"."country_id" = ?'));
      expect(dbSpy.lastArgs, [1]);
    });

    test('It eager loads distant relations correctly', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 10, 'country_id': 1},
          {'id': 20, 'country_id': 2},
        ],
        'FROM posts': [
          {'id': 100, 'title': 'Pasta Recipe', 'user_id': 10},
          {'id': 200, 'title': 'Baguette Recipe', 'user_id': 20},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final countries = [
        Country({'id': 1, 'name': 'Italy'}),
        Country({'id': 2, 'name': 'France'}),
      ];

      await countries.first.posts().match(countries, 'posts');

      final italyPosts = countries[0].relations['posts'] as List;
      final francePosts = countries[1].relations['posts'] as List;

      expect(italyPosts, hasLength(1));
      expect(italyPosts.first, isA<Post>());
      expect((italyPosts.first as Post).attributes['title'], 'Pasta Recipe');

      expect(francePosts, hasLength(1));
      expect(
        (francePosts.first as Post).attributes['title'],
        'Baguette Recipe',
      );
    });
  });
}


--- FILE: test/relations/morph_many_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';

  Post([super.attributes]);

  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);

  MorphMany<Comment> comments() {
    return morphMany(Comment.new, 'commentable');
  }
}

class Comment extends Model {
  @override
  String get table => 'comments';

  Comment([super.attributes]);

  @override
  Comment fromMap(Map<String, dynamic> map) => Comment(map);
}

void main() {
  group('MorphMany Relation', () {
    test(
      'It generates SQL with Type and ID constraints for lazy loading',
      () async {
        final dbSpy = MockDatabaseSpy();
        DatabaseManager().setDatabase(dbSpy);

        final post = Post({'id': 1});

        await post.comments().get();

        expect(dbSpy.lastSql, contains('FROM "comments"'));
        expect(dbSpy.lastSql, contains('WHERE "commentable_type" = ?'));
        expect(dbSpy.lastSql, contains('AND "commentable_id" = ?'));

        expect(dbSpy.lastArgs, contains('posts'));
        expect(dbSpy.lastArgs, contains('1'));
      },
    );

    test('It eager loads children filtering by Type correctly', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM comments': [
          {
            'id': 100,
            'body': 'Nice Post',
            'commentable_type': 'posts',
            'commentable_id': 1,
          },
          {
            'id': 101,
            'body': 'Bad Post',
            'commentable_type': 'posts',
            'commentable_id': 2,
          },
          {
            'id': 102,
            'body': 'Nice Video',
            'commentable_type': 'videos',
            'commentable_id': 1,
          },
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
        Post({'id': 2}),
      ];

      await posts.first.comments().match(posts, 'comments');

      final commentsPost1 = posts[0].relations['comments'] as List;
      final commentsPost2 = posts[1].relations['comments'] as List;

      expect(commentsPost1, hasLength(1));
      expect((commentsPost1.first as Comment).attributes['body'], 'Nice Post');

      expect(commentsPost2, hasLength(1));
      expect((commentsPost2.first as Comment).attributes['body'], 'Bad Post');
    });
  });
}


--- FILE: test/relations/belongs_to_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);
}

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);

  BelongsTo<User> author() {
    return belongsTo(User.new, foreignKey: 'user_id', ownerKey: 'id');
  }
}

void main() {
  group('BelongsTo Relation', () {
    test('It generates correct SQL for single parent', () async {
      final dbSpy = MockDatabaseSpy();
      DatabaseManager().setDatabase(dbSpy);

      final post = Post({'id': 1, 'title': 'Hello World', 'user_id': 99});

      await post.author().get();

      expect(dbSpy.lastSql, contains('FROM "users"'));
      expect(dbSpy.lastSql, contains('WHERE "id" = ?'));
      expect(dbSpy.lastArgs, [99]);
    });

    test('It eager loads parents correctly', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 10, 'name': 'David'},
          {'id': 11, 'name': 'Romolo'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1, 'user_id': 10}),
        Post({'id': 2, 'user_id': 11}),
        Post({'id': 3, 'user_id': 10}),
      ];

      await posts.first.author().match(posts, 'author');

      final author1 = posts[0].relations['author'] as User?;
      final author2 = posts[1].relations['author'] as User?;
      final author3 = posts[2].relations['author'] as User?;

      expect(author1, isNotNull);
      expect(author1!.id, 10);
      expect(author1.attributes['name'], 'David');

      expect(author2, isNotNull);
      expect(author2!.id, 11);

      expect(author3, isNotNull);
      expect(author3!.id, 10);
    });
  });
}


--- FILE: test/relations/morph_to_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);
}

class Video extends Model {
  @override
  String get table => 'videos';
  Video([super.attributes]);
  @override
  Video fromMap(Map<String, dynamic> map) => Video(map);
}

class Comment extends Model {
  @override
  String get table => 'comments';
  Comment([super.attributes]);
  @override
  Comment fromMap(Map<String, dynamic> map) => Comment(map);

  MorphTo<Model> commentable() {
    return morphToTyped('commentable', {
      'posts': Post.new,
      'videos': Video.new,
    });
  }
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('MorphTo Extended', () {
    test('returns null when type is null', () async {
      final comment = Comment({
        'id': 1,
        'commentable_type': null,
        'commentable_id': 100,
      });

      final parent = await comment.commentable().getResult();

      expect(parent, isNull);
    });

    test('returns null when id is null', () async {
      final comment = Comment({
        'id': 1,
        'commentable_type': 'posts',
        'commentable_id': null,
      });

      final parent = await comment.commentable().getResult();

      expect(parent, isNull);
    });

    test('returns null when type not in typeMap', () async {
      final comment = Comment({
        'id': 1,
        'commentable_type': 'unknown_type',
        'commentable_id': 100,
      });

      final parent = await comment.commentable().getResult();

      expect(parent, isNull);
    });

    test('get() throws UnsupportedError', () {
      final comment = Comment({
        'id': 1,
        'commentable_type': 'posts',
        'commentable_id': 100,
      });

      expect(
        () => comment.commentable().get(),
        throwsA(isA<UnsupportedError>()),
      );
    });

    test('watch() throws UnsupportedError', () {
      final comment = Comment({
        'id': 1,
        'commentable_type': 'posts',
        'commentable_id': 100,
      });

      expect(
        () => comment.commentable().watch(),
        throwsA(isA<UnsupportedError>()),
      );
    });

    test('eager load groups by type efficiently', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM posts': [
          {'id': 100, 'title': 'Post A'},
          {'id': 101, 'title': 'Post B'},
        ],
        'FROM videos': [
          {'id': 200, 'title': 'Video A'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final comments = [
        Comment({'id': 1, 'commentable_type': 'posts', 'commentable_id': 100}),
        Comment({'id': 2, 'commentable_type': 'posts', 'commentable_id': 101}),
        Comment({'id': 3, 'commentable_type': 'videos', 'commentable_id': 200}),
      ];

      await comments.first.commentable().match(comments, 'commentable');

      // Should have made 2 queries (one per type), not 3
      final fromPostsCount = mockDb.history
          .where((s) => s.contains('FROM "posts"'))
          .length;
      final fromVideosCount = mockDb.history
          .where((s) => s.contains('FROM "videos"'))
          .length;

      expect(fromPostsCount, 1);
      expect(fromVideosCount, 1);
    });

    test('eager load with unknown type in data', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM posts': [
          {'id': 100, 'title': 'Post A'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final comments = [
        Comment({'id': 1, 'commentable_type': 'posts', 'commentable_id': 100}),
        Comment({
          'id': 2,
          'commentable_type': 'unknown',
          'commentable_id': 999,
        }),
      ];

      await comments.first.commentable().match(comments, 'commentable');

      expect(comments[0].relations['commentable'], isA<Post>());
      expect(comments[1].relations.containsKey('commentable'), isFalse);
    });
  });
}


--- FILE: test/relations/belongs_to_many_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Role extends Model {
  @override
  String get table => 'roles';
  Role([super.attributes]);
  @override
  Role fromMap(Map<String, dynamic> map) => Role(map);
}

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);

  BelongsToMany<Role> roles() {
    return belongsToMany(
      Role.new,
      'role_user',
      foreignPivotKey: 'user_id',
      relatedPivotKey: 'role_id',
    );
  }
}

void main() {
  test('BelongsToMany loads related models via pivot', () async {
    final mockDb = MockDatabaseSpy([], {
      'FROM role_user': [
        {'user_id': 1, 'role_id': 10},
        {'user_id': 1, 'role_id': 11},
      ],
      'FROM roles': [
        {'id': 10, 'name': 'Admin'},
        {'id': 11, 'name': 'Editor'},
      ],
    });
    DatabaseManager().setDatabase(mockDb);

    final users = [
      User({'id': 1}),
    ];

    await users.first.roles().match(users, 'roles');

    final roles = users.first.relations['roles'] as List;

    expect(roles, hasLength(2));
    expect(roles.first, isA<Role>());

    final adminRole = roles.firstWhere((r) => r.id == 10);
    expect(adminRole.attributes['name'], 'Admin');
  });
}


--- FILE: test/relations/relations_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';

  @override
  String get primaryKey => 'id';

  User([super.attributes]);

  @override
  User fromMap(Map<String, dynamic> map) => User(map);

  HasOne<Profile> profile() => hasOne(Profile.new);
  HasMany<Post> posts() => hasMany(Post.new);

  @override
  Relation? getRelation(String name) {
    switch (name) {
      case 'profile':
        return profile();
      case 'posts':
        return posts();
      default:
        return null;
    }
  }
}

class Profile extends Model {
  @override
  String get table => 'profiles';

  Profile([super.attributes]);

  @override
  Profile fromMap(Map<String, dynamic> map) => Profile(map);

  BelongsTo<User> user() =>
      belongsTo(User.new, foreignKey: 'user_id', ownerKey: 'id');
}

class Post extends Model {
  @override
  String get table => 'posts';

  Post([super.attributes]);

  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);

  BelongsTo<User> author() =>
      belongsTo(User.new, foreignKey: 'user_id', ownerKey: 'id');
}

class CustomPkUser extends Model {
  @override
  String get table => 'users';

  @override
  String get primaryKey => 'uuid';

  CustomPkUser([super.attributes]);

  @override
  CustomPkUser fromMap(Map<String, dynamic> map) => CustomPkUser(map);

  HasMany<CustomPkPost> posts() =>
      hasMany(CustomPkPost.new, foreignKey: 'author_uuid', localKey: 'uuid');
}

class CustomPkPost extends Model {
  @override
  String get table => 'posts';

  CustomPkPost([super.attributes]);

  @override
  CustomPkPost fromMap(Map<String, dynamic> map) => CustomPkPost(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Relations - General', () {
    test('getRelation returns null for undefined relation', () {
      final user = User({'id': 1});
      expect(user.getRelation('nonexistent'), isNull);
    });

    test('relation query can be further constrained', () async {
      final user = User({'id': 1});

      await user.posts().where('published', true).orderBy('created_at').get();

      expect(dbSpy.lastSql, contains('"user_id" = ?'));
      expect(dbSpy.lastSql, contains('"published" = ?'));
      expect(dbSpy.lastSql, contains('ORDER BY "created_at"'));
    });

    test('relation with custom primary key', () async {
      final user = CustomPkUser({'uuid': 'abc-123'});

      await user.posts().get();

      expect(dbSpy.lastSql, contains('"author_uuid" = ?'));
      expect(dbSpy.lastArgs, contains('abc-123'));
    });
  });

  // ===========================================================================
  // HAS ONE
  // ===========================================================================
  group('HasOne Extended', () {
    test('returns null when no related model exists', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final user = User({'id': 1});
      final profile = await user.profile().getResult();

      expect(profile, isNull);
    });

    test('getResult() applies LIMIT 1', () async {
      final user = User({'id': 1});
      await user.profile().getResult();

      expect(dbSpy.lastSql, contains('LIMIT 1'));
    });

    test('eager load with empty parent list', () async {
      final users = <User>[];

      if (users.isNotEmpty) {
        await users.first.profile().match(users, 'profile');
      }

      expect(dbSpy.history, isEmpty);
    });

    test('eager load when some parents have no related', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM profiles': [
          {'id': 100, 'user_id': 1, 'bio': 'Bio 1'},
          // No profile for user 2
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final users = [
        User({'id': 1}),
        User({'id': 2}),
      ];

      await users.first.profile().match(users, 'profile');

      expect(users[0].relations['profile'], isA<Profile>());
      expect(users[1].relations['profile'], isNull);
    });

    test('custom foreign key', () async {
      final user = User({'id': 1});
      final customRelation = HasOne<Profile>(
        user,
        Profile.new,
        'custom_user_id',
        'id',
      );

      await customRelation.get();

      expect(dbSpy.lastSql, contains('"custom_user_id" = ?'));
    });
  });

  // ===========================================================================
  // HAS MANY
  // ===========================================================================
  group('HasMany Extended', () {
    test('returns empty list when no children', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final user = User({'id': 1});
      final posts = await user.posts().get();

      expect(posts, isEmpty);
    });

    test('eager load distributes correctly to parents', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM posts': [
          {'id': 1, 'user_id': 1, 'title': 'Post A'},
          {'id': 2, 'user_id': 1, 'title': 'Post B'},
          {'id': 3, 'user_id': 2, 'title': 'Post C'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final users = [
        User({'id': 1}),
        User({'id': 2}),
      ];

      await users.first.posts().match(users, 'posts');

      expect((users[0].relations['posts'] as List).length, 2);
      expect((users[1].relations['posts'] as List).length, 1);
    });

    test('chained where on relation query', () async {
      final user = User({'id': 1});

      await user
          .posts()
          .where('status', 'published')
          .where('views', 100, '>')
          .get();

      expect(dbSpy.lastSql, contains('"user_id" = ?'));
      expect(dbSpy.lastSql, contains('"status" = ?'));
      expect(dbSpy.lastSql, contains('"views" > ?'));
    });

    test('orderBy on relation query', () async {
      final user = User({'id': 1});

      await user.posts().orderBy('created_at', direction: 'DESC').get();

      expect(dbSpy.lastSql, contains('ORDER BY "created_at" DESC'));
    });

    test('limit on relation query', () async {
      final user = User({'id': 1});

      await user.posts().limit(5).get();

      expect(dbSpy.lastSql, contains('LIMIT 5'));
    });
  });

  // ===========================================================================
  // BELONGS TO
  // ===========================================================================
  group('BelongsTo Extended', () {
    test('returns null when foreign key is null', () async {
      final post = Post({'id': 1, 'user_id': null});
      final author = await post.author().getResult();

      expect(author, isNull);
    });

    test('eager load skips null foreign keys', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 1, 'name': 'David'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1, 'user_id': 1}),
        Post({'id': 2, 'user_id': null}),
      ];

      await posts.first.author().match(posts, 'author');

      expect(posts[0].relations['author'], isA<User>());
      expect(posts[1].relations.containsKey('author'), isFalse);
    });

    test('eager load with mixed null/valid foreign keys', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 1, 'name': 'David'},
          {'id': 2, 'name': 'Romolo'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1, 'user_id': 1}),
        Post({'id': 2, 'user_id': null}),
        Post({'id': 3, 'user_id': 2}),
      ];

      await posts.first.author().match(posts, 'author');

      expect((posts[0].relations['author'] as User).id, 1);
      expect(posts[1].relations.containsKey('author'), isFalse);
      expect((posts[2].relations['author'] as User).id, 2);
    });
  });
}


--- FILE: test/relations/relations_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class TypedPost extends Model {
  @override
  String get table => 'posts';

  TypedPost([super.attributes]);
  @override
  TypedPost fromMap(Map<String, dynamic> map) => TypedPost(map);

  BelongsTo<TypedUser> author() {
    return belongsTo(TypedUser.new, foreignKey: 'user_id', ownerKey: 'id');
  }

  @override
  Relation? getRelation(String name) {
    if (name == 'author') return author();
    return super.getRelation(name);
  }

  TypedUser? get authorModel => getRelated<TypedUser>('author');
}

class TypedUser extends Model {
  @override
  String get table => 'users';

  TypedUser([super.attributes]);
  @override
  TypedUser fromMap(Map<String, dynamic> map) => TypedUser(map);

  HasMany<TypedPost> posts() => hasMany(TypedPost.new);

  @override
  Relation? getRelation(String name) {
    if (name == 'posts') return posts();
    return super.getRelation(name);
  }

  List<TypedPost> get postsList => getRelationList<TypedPost>('posts');
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Typed Relations & Accessors', () {
    test('It accesses HasMany relations as List<T> via getter', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': 1, 'name': 'David'},
        ],
        'FROM posts': [
          {'id': 100, 'user_id': 1, 'title': 'Post A'},
          {'id': 101, 'user_id': 1, 'title': 'Post B'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final users = await TypedUser().query().withRelations(['posts']).get();
      final user = users.first;

      expect(user.postsList, isA<List<TypedPost>>());
      expect(user.postsList, hasLength(2));
      expect(user.postsList.first.attributes['title'], 'Post A');
    });

    test('It accesses BelongsTo relation as T? via getter', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM posts': [
          {'id': 100, 'user_id': 1, 'title': 'Post A'},
        ],
        'FROM users': [
          {'id': 1, 'name': 'David'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = await TypedPost().query().withRelations(['author']).get();
      final post = posts.first;

      expect(post.authorModel, isA<TypedUser>());
      expect(post.authorModel?.attributes['name'], 'David');
    });

    test(
      'It returns empty list instead of null for missing HasMany relations',
      () async {
        final mockDb = MockDatabaseSpy([], {
          'FROM users': [
            {'id': 1, 'name': 'David'},
          ],
        });
        DatabaseManager().setDatabase(mockDb);

        final users = await TypedUser().query().get();

        expect(users.first.postsList, isA<List<TypedPost>>());
        expect(users.first.postsList, isEmpty);
      },
    );

    test('It returns null for missing HasOne/BelongsTo relations', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM posts': [
          {'id': 100, 'user_id': 1},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = await TypedPost().query().get();

      expect(posts.first.authorModel, isNull);
    });
  });
}


--- FILE: test/relations/morph_to_many_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);

  MorphToMany<Tag> tags() => morphToMany(Tag.new, 'taggable');
}

class Video extends Model {
  @override
  String get table => 'videos';
  Video([super.attributes]);
  @override
  Video fromMap(Map<String, dynamic> map) => Video(map);

  MorphToMany<Tag> tags() => morphToMany(Tag.new, 'taggable');
}

class Tag extends Model {
  @override
  String get table => 'tags';
  Tag([super.attributes]);
  @override
  Tag fromMap(Map<String, dynamic> map) => Tag(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('MorphToMany Extended', () {
    test('returns empty when no pivot entries', () async {
      final mockDb = MockDatabaseSpy([], {'FROM taggables': []});
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
      ];
      await posts.first.tags().match(posts, 'tags');

      // Usa getRelationList per gestire il caso null
      final tags = posts.first.getRelationList<Tag>('tags');
      expect(tags, isEmpty);
    });

    test('filters by parent type in pivot', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM taggables': [
          {'tag_id': 10, 'taggable_id': 1, 'taggable_type': 'posts'},
          {
            'tag_id': 11,
            'taggable_id': 1,
            'taggable_type': 'videos',
          }, // Different type
        ],
        'FROM tags': [
          {'id': 10, 'name': 'Flutter'},
          {'id': 11, 'name': 'Dart'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
      ];
      await posts.first.tags().match(posts, 'tags');

      final tags = posts.first.relations['tags'] as List;

      // Should only include tags for 'posts' type
      expect(tags.length, 1);
      expect((tags.first as Tag).attributes['name'], 'Flutter');
    });

    test('eager load with multiple parent types', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM taggables': [
          {'tag_id': 10, 'taggable_id': 1, 'taggable_type': 'posts'},
          {'tag_id': 11, 'taggable_id': 1, 'taggable_type': 'posts'},
        ],
        'FROM tags': [
          {'id': 10, 'name': 'Flutter'},
          {'id': 11, 'name': 'Dart'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
      ];
      await posts.first.tags().match(posts, 'tags');

      final tags = posts.first.relations['tags'] as List;
      expect(tags.length, 2);
    });

    test('pivot table naming convention', () async {
      final post = Post({'id': 1});
      await post.tags().get();

      // Should use 'taggables' (name + 's')
      expect(dbSpy.lastSql, contains('taggables'));
    });
  });
}


--- FILE: test/relations/belongs_to_many_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';

  User([super.attributes]);

  @override
  User fromMap(Map<String, dynamic> map) => User(map);

  BelongsToMany<Role> roles() => belongsToMany(
    Role.new,
    'role_user',
    foreignPivotKey: 'user_id',
    relatedPivotKey: 'role_id',
  );
}

class Role extends Model {
  @override
  String get table => 'roles';

  Role([super.attributes]);

  @override
  Role fromMap(Map<String, dynamic> map) => Role(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('BelongsToMany Extended', () {
    test('returns empty list when no pivot entries', () async {
      final emptyMock = MockDatabaseSpy([], {'FROM role_user': []});
      DatabaseManager().setDatabase(emptyMock);

      final users = [
        User({'id': 1}),
      ];
      await users.first.roles().match(users, 'roles');

      // Quando non ci sono pivot entries, la relazione potrebbe non essere settata
      // Usa l'accessor sicuro getRelationList
      final roles = users.first.getRelationList<Role>('roles');
      expect(roles, isEmpty);
    });

    test('handles duplicate pivot entries', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM role_user': [
          {'user_id': 1, 'role_id': 10},
          {'user_id': 1, 'role_id': 10}, // Duplicate
          {'user_id': 1, 'role_id': 11},
        ],
        'FROM roles': [
          {'id': 10, 'name': 'Admin'},
          {'id': 11, 'name': 'Editor'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final users = [
        User({'id': 1}),
      ];
      await users.first.roles().match(users, 'roles');

      // Should have 3 entries (including duplicate)
      final roles = users.first.relations['roles'] as List;
      expect(roles.length, 3);
    });

    test('eager load with empty pivot table', () async {
      final mockDb = MockDatabaseSpy([], {'FROM role_user': []});
      DatabaseManager().setDatabase(mockDb);

      final users = [
        User({'id': 1}),
        User({'id': 2}),
      ];

      await users.first.roles().match(users, 'roles');

      expect(users[0].getRelationList<Role>('roles'), isEmpty);
      expect(users[1].getRelationList<Role>('roles'), isEmpty);
    });

    test('custom pivot table name', () async {
      final user = User({'id': 1});
      await user.roles().get();

      expect(dbSpy.lastSql, contains('JOIN "role_user" ON'));
    });

    test('custom pivot keys', () async {
      final user = User({'id': 1});
      await user.roles().get();

      expect(dbSpy.lastSql, contains('"role_user"."user_id" = ?'));
    });
  });
}


--- FILE: test/relations/has_many_soft_delete_test.dart ---
import 'package:bavard/bavard.dart';
import 'package:test/test.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';

  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);

  HasMany<Post> posts() => hasMany(Post.new);
}

class Post extends Model with HasSoftDeletes {
  @override
  String get table => 'posts';

  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {});
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Relations vs Global Scopes', () {
    test(
      'hasMany should respect Soft Deletes (Global Scope) of related model',
      () async {
        dbSpy.setMockData({
          'SELECT * FROM posts WHERE user_id = ? AND deleted_at IS NULL': [
            {
              'id': 10,
              'user_id': 1,
              'title': 'Active Post',
              'deleted_at': null,
            },
          ],
          'SELECT * FROM posts WHERE user_id = ?': [
            {
              'id': 10,
              'user_id': 1,
              'title': 'Active Post',
              'deleted_at': null,
            },
            {
              'id': 11,
              'user_id': 1,
              'title': 'Deleted Post',
              'deleted_at': '2023-01-01',
            },
          ],
        });

        final user = User({'id': 1});

        await user.posts().get();

        expect(
          dbSpy.lastSql,
          contains('"deleted_at" IS NULL'),
          reason: 'La relazione ha ignorato il Soft Delete del modello figlio!',
        );
      },
    );
  });
}


--- FILE: test/relations/has_one_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);

  HasOne<Profile> profile() {
    return hasOne(Profile.new);
  }
}

class Profile extends Model {
  @override
  String get table => 'profiles';
  Profile([super.attributes]);
  @override
  Profile fromMap(Map<String, dynamic> map) => Profile(map);
}

void main() {
  group('HasOne Relation', () {
    test('It generates SQL with LIMIT 1 for lazy loading', () async {
      final dbSpy = MockDatabaseSpy();
      DatabaseManager().setDatabase(dbSpy);

      final user = User({'id': 1});

      await user.profile().getResult();

      expect(dbSpy.lastSql, contains('FROM "profiles"'));
      expect(dbSpy.lastSql, contains('WHERE "user_id" = ?'));
      expect(dbSpy.lastSql, contains('LIMIT 1'));
      expect(dbSpy.lastArgs, [1]);
    });

    test('It eager loads relation and unwraps list', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM profiles': [
          {'id': 100, 'user_id': 1, 'bio': 'Bio User 1'},
          {'id': 101, 'user_id': 2, 'bio': 'Bio User 2'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final users = [
        User({'id': 1}),
        User({'id': 2}),
      ];

      await users.first.profile().match(users, 'profile');

      final profile1 = users[0].relations['profile'];
      final profile2 = users[1].relations['profile'];

      expect(profile1, isA<Profile>());
      expect((profile1 as Profile).attributes['bio'], 'Bio User 1');

      expect(profile2, isA<Profile>());
      expect((profile2 as Profile).attributes['bio'], 'Bio User 2');
    });
  });
}


--- FILE: test/relations/morph_one_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);

  MorphOne<Image> image() {
    return MorphOne(this, Image.new, 'imageable');
  }
}

class Image extends Model {
  @override
  String get table => 'images';
  Image([super.attributes]);
  @override
  Image fromMap(Map<String, dynamic> map) => Image(map);
}

void main() {
  group('MorphOne Relation', () {
    test('It generates correct SQL constraints for lazy loading', () async {
      final dbSpy = MockDatabaseSpy();
      DatabaseManager().setDatabase(dbSpy);

      final post = Post({'id': 1});

      await post.image().get();

      expect(dbSpy.lastSql, contains('FROM "images"'));

      expect(dbSpy.lastSql, contains('"imageable_type" = ?'));

      expect(dbSpy.lastSql, contains('"imageable_id" = ?'));

      expect(dbSpy.lastArgs, contains('posts'));
      expect(dbSpy.lastArgs, contains('1'));
    });

    test('It eager loads and unwraps the result to a single Model', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM images': [
          {
            'id': 500,
            'url': 'cover.jpg',
            'imageable_type': 'posts',
            'imageable_id': 1,
          },
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
        Post({'id': 2}),
      ];

      await posts.first.image().match(posts, 'image');

      final imagePost1 = posts[0].relations['image'];
      expect(imagePost1, isA<Image>());
      expect((imagePost1 as Image).attributes['url'], 'cover.jpg');

      final imagePost2 = posts[1].relations['image'];
      expect(imagePost2, isNull);
    });
  });
}


--- FILE: test/relations/morph_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);

  MorphMany<Comment> comments() => morphMany(Comment.new, 'commentable');
  MorphOne<Image> image() => morphOne(Image.new, 'imageable');
}

class Video extends Model {
  @override
  String get table => 'videos';
  Video([super.attributes]);
  @override
  Video fromMap(Map<String, dynamic> map) => Video(map);

  MorphMany<Comment> comments() => morphMany(Comment.new, 'commentable');
}

class Comment extends Model {
  @override
  String get table => 'comments';
  Comment([super.attributes]);
  @override
  Comment fromMap(Map<String, dynamic> map) => Comment(map);
}

class Image extends Model {
  @override
  String get table => 'images';
  Image([super.attributes]);
  @override
  Image fromMap(Map<String, dynamic> map) => Image(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('MorphMany Extended', () {
    test('returns empty list when no children', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final post = Post({'id': 1});
      final comments = await post.comments().get();

      expect(comments, isEmpty);
    });

    test('filters by type excludes other types', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM comments': [
          {
            'id': 1,
            'commentable_type': 'posts',
            'commentable_id': 1,
            'body': 'Post comment',
          },
          {
            'id': 2,
            'commentable_type': 'videos',
            'commentable_id': 1,
            'body': 'Video comment',
          },
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
      ];
      await posts.first.comments().match(posts, 'comments');

      final postComments = posts.first.relations['comments'] as List;

      // Should only include post comments, not video comments
      expect(postComments.length, 1);
      expect(
        (postComments.first as Comment).attributes['body'],
        'Post comment',
      );
    });

    test('eager load groups by parent id AND type', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM comments': [
          {'id': 1, 'commentable_type': 'posts', 'commentable_id': 1},
          {'id': 2, 'commentable_type': 'posts', 'commentable_id': 2},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
        Post({'id': 2}),
      ];

      await posts.first.comments().match(posts, 'comments');

      expect((posts[0].relations['comments'] as List).length, 1);
      expect((posts[1].relations['comments'] as List).length, 1);
    });
  });

  group('MorphOne Extended', () {
    test('returns null when no polymorphic child', () async {
      final emptyMock = MockDatabaseSpy([], {});
      DatabaseManager().setDatabase(emptyMock);

      final posts = [
        Post({'id': 1}),
      ];
      await posts.first.image().match(posts, 'image');

      expect(posts.first.relations['image'], isNull);
    });

    test('eager load unwraps to single model', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM images': [
          {
            'id': 100,
            'imageable_type': 'posts',
            'imageable_id': 1,
            'url': 'test.jpg',
          },
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
      ];
      await posts.first.image().match(posts, 'image');

      expect(posts.first.relations['image'], isA<Image>());
      expect(
        (posts.first.relations['image'] as Image).attributes['url'],
        'test.jpg',
      );
    });

    test('eager load sets null for missing', () async {
      final mockDb = MockDatabaseSpy([], {
        'FROM images': [
          {'id': 100, 'imageable_type': 'posts', 'imageable_id': 1},
          // No image for post 2
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final posts = [
        Post({'id': 1}),
        Post({'id': 2}),
      ];

      await posts.first.image().match(posts, 'image');

      expect(posts[0].relations['image'], isA<Image>());
      expect(posts[1].relations['image'], isNull);
    });
  });
}


--- FILE: test/relations/has_many_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class Post extends Model {
  @override
  String get table => 'posts';
  Post([super.attributes]);
  @override
  Post fromMap(Map<String, dynamic> map) => Post(map);
}

class User extends Model {
  @override
  String get table => 'users';
  User([super.attributes]);
  @override
  User fromMap(Map<String, dynamic> map) => User(map);

  HasMany<Post> posts() => hasMany(Post.new);

  @override
  Relation? getRelation(String name) {
    if (name == 'posts') return posts();
    return super.getRelation(name);
  }
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([
      {'id': 10, 'user_id': 1, 'title': 'Post A'},
      {'id': 11, 'user_id': 1, 'title': 'Post B'},
      {'id': 12, 'user_id': 2, 'title': 'Post C'},
    ]);
    DatabaseManager().setDatabase(dbSpy);
  });

  group('HasMany Relation', () {
    test('It constructs the correct SQL constraints', () async {
      final user = User({'id': 1});
      await user.posts().get();

      expect(dbSpy.lastSql, contains('SELECT "posts".* FROM "posts"'));
      expect(dbSpy.lastSql, contains('WHERE "user_id" = ?'));
      expect(dbSpy.lastArgs, [1]);
    });

    test('It eager loads children correctly', () async {
      final users = [
        User({'id': 1}),
        User({'id': 2}),
      ];

      final relation = users.first.posts();

      await relation.match(users, 'posts');

      expect(dbSpy.lastSql, contains('WHERE "user_id" IN (?, ?)'));

      expect(users.first.relations['posts'], hasLength(2));
      expect(users.last.relations['posts'], hasLength(1));

      final firstPost = (users.first.relations['posts'] as List).first;
      expect(firstPost, isA<Post>());
      expect(firstPost.attributes['title'], 'Post A');
    });
  });
}


--- FILE: test/schema/columns_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/schema.dart';

enum UserRole { admin, editor, guest }

void main() {
  group('Column Base Methods', () {
    const col = TextColumn('status');

    test('equals', () {
      final condition = col.equals('active');
      expect(condition.column, 'status');
      expect(condition.operator, '=');
      expect(condition.value, 'active');
    });

    test('notEquals', () {
      final condition = col.notEquals('inactive');
      expect(condition.column, 'status');
      expect(condition.operator, '!=');
      expect(condition.value, 'inactive');
    });

    test('isNull', () {
      final condition = col.isNull();
      expect(condition.column, 'status');
      expect(condition.operator, 'IS');
      expect(condition.value, null);
    });

    test('isNotNull', () {
      final condition = col.isNotNull();
      expect(condition.column, 'status');
      expect(condition.operator, 'IS NOT');
      expect(condition.value, null);
    });

    test('inList', () {
      final values = ['active', 'pending'];
      final condition = col.inList(values);
      expect(condition.column, 'status');
      expect(condition.operator, 'IN');
      expect(condition.value, values);
    });

    test('notInList', () {
      final values = ['banned', 'deleted'];
      final condition = col.notInList(values);
      expect(condition.column, 'status');
      expect(condition.operator, 'NOT IN');
      expect(condition.value, values);
    });
  });

  group('TextColumn', () {
    const col = TextColumn('username');

    test('contains', () {
      final condition = col.contains('dav');
      expect(condition.column, 'username');
      expect(condition.operator, 'LIKE');
      expect(condition.value, '%dav%');
    });

    test('startsWith', () {
      final condition = col.startsWith('admin');
      expect(condition.column, 'username');
      expect(condition.operator, 'LIKE');
      expect(condition.value, 'admin%');
    });

    test('endsWith', () {
      final condition = col.endsWith('_test');
      expect(condition.column, 'username');
      expect(condition.operator, 'LIKE');
      expect(condition.value, '%_test');
    });
  });

  group('IntColumn', () {
    const col = IntColumn('age');

    test('greaterThan', () {
      final condition = col.greaterThan(18);
      expect(condition.column, 'age');
      expect(condition.operator, '>');
      expect(condition.value, 18);
    });

    test('between', () {
      final condition = col.between(20, 30);
      expect(condition.column, 'age');
      expect(condition.operator, 'BETWEEN');
      expect(condition.value, [20, 30]);
    });
  });

  group('BoolColumn', () {
    const col = BoolColumn('is_active');

    test('isTrue', () {
      final condition = col.isTrue();
      expect(condition.column, 'is_active');
      expect(condition.operator, '=');
      expect(condition.value, 1);
    });

    test('isFalse', () {
      final condition = col.isFalse();
      expect(condition.column, 'is_active');
      expect(condition.operator, '=');
      expect(condition.value, 0);
    });
  });

  group('DateTimeColumn', () {
    const col = DateTimeColumn('created_at');
    final date = DateTime(2025, 12, 25, 10, 0, 0);

    test('after', () {
      final condition = col.after(date);
      expect(condition.column, 'created_at');
      expect(condition.operator, '>');
      expect(condition.value, date.toIso8601String());
    });

    test('between', () {
      final end = date.add(Duration(days: 1));
      final condition = col.between(date, end);
      expect(condition.operator, 'BETWEEN');
      expect(condition.value, [date, end]);
    });
  });

  group('EnumColumn', () {
    const col = EnumColumn<UserRole>('role');

    test('equals (uses name)', () {
      final condition = col.equals(UserRole.admin);
      expect(condition.operator, '=');
      expect(condition.value, 'admin');
    });

    test('inList (uses names)', () {
      final condition = col.inList([UserRole.editor, UserRole.guest]);
      expect(condition.operator, 'IN');
      expect(condition.value, ['editor', 'guest']);
    });
  });

  group('JsonColumn & JsonPathColumn', () {
    const col = JsonColumn('metadata');

    test('creates JsonPathColumn via key()', () {
      final pathCol = col.key<String>('settings');
      expect(pathCol.toString(), "json_extract(metadata, '\$.settings')");
    });

    test('nested path chaining', () {
      final pathCol = col.key<dynamic>('settings').key<String>('theme');
      expect(pathCol.toString(), "json_extract(metadata, '\$.settings.theme')");
    });

    test('array index chaining', () {
      final pathCol = col.key<dynamic>('tags').index<String>(0);
      expect(pathCol.toString(), "json_extract(metadata, '\$.tags[0]')");
    });

    test('operators on JsonPathColumn', () {
      final pathCol = col.key<int>('login_count');
      final condition = pathCol.greaterThan(5);

      expect(condition.column, "json_extract(metadata, '\$.login_count')");
      expect(condition.operator, '>');
      expect(condition.value, 5);
    });
  });
}

--- FILE: test/core/concerns/has_timestamps_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class TimestampUser extends Model with HasTimestamps {
  @override
  String get table => 'users';

  TimestampUser([super.attributes]);

  @override
  TimestampUser fromMap(Map<String, dynamic> map) => TimestampUser(map);

  @override
  Map<String, String> get casts => {
    'created_at': 'datetime',
    'updated_at': 'datetime',
  };
}

class CustomTimestampUser extends Model with HasTimestamps {
  @override
  String get table => 'users';

  @override
  String get createdAtColumn => 'date_created';

  @override
  String get updatedAtColumn => 'date_modified';

  CustomTimestampUser([super.attributes]);

  @override
  CustomTimestampUser fromMap(Map<String, dynamic> map) =>
      CustomTimestampUser(map);
}

class NoTimestampUser extends Model with HasTimestamps {
  @override
  String get table => 'users';

  @override
  bool get timestamps => false;

  NoTimestampUser([super.attributes]);

  @override
  NoTimestampUser fromMap(Map<String, dynamic> map) => NoTimestampUser(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'last_insert_row_id': [
        {'id': 1},
      ],
      'FROM users': [
        {
          'id': 1,
          'name': 'David',
          'created_at': '2024-01-01T10:00:00.000',
          'updated_at': '2024-01-01T10:00:00.000',
        },
      ],
    });

    DatabaseManager().setDatabase(dbSpy);
  });

  group('HasTimestamps Mixin', () {
    test('INSERT sets created_at and updated_at automatically', () async {
      final user = TimestampUser({'name': 'David'});
      await user.save();

      final insertSql = dbSpy.history.firstWhere(
        (sql) => sql.contains('INSERT INTO users'),
      );

      expect(insertSql, contains('created_at'));
      expect(insertSql, contains('updated_at'));
    });

    test('UPDATE updates only updated_at', () async {
      final user = TimestampUser({
        'id': 1,
        'name': 'David',
        'created_at': DateTime(2024, 1, 1),
        'updated_at': DateTime(2024, 1, 1),
      });
      user.exists = true;
      user.syncOriginal();

      user.attributes['name'] = 'Romolo';

      await user.save();

      final updateSql = dbSpy.history.firstWhere(
        (sql) => sql.contains('UPDATE "users"'),
      );

      expect(updateSql, contains('"updated_at" = ?'));
      expect(updateSql, isNot(contains('"created_at" = ?')));
    });

    test('updated_at changes on every save', () async {
      final user = TimestampUser({
        'id': 1,
        'name': 'David',
        'created_at': DateTime(2024, 1, 1),
        'updated_at': DateTime(2024, 1, 1),
      });

      user.syncOriginal();

      await Future.delayed(const Duration(milliseconds: 10));
      await user.save();

      final updatedAt = user.date('updated_at');

      expect(updatedAt, isNotNull);
      expect(updatedAt!.isAfter(DateTime(2024, 1, 1)), isTrue);
    });

    test('timestamps can be disabled per model', () async {
      final user = NoTimestampUser({'name': 'No TS'});

      await user.save();

      final insertArgs = dbSpy.lastArgs!;

      final hasDateTime = insertArgs.any((v) => v is DateTime);

      expect(hasDateTime, isFalse);
    });

    test('created_at is not included in UPDATE statement', () async {
      final user = TimestampUser({
        'id': 1,
        'name': 'David',
        'created_at': DateTime(2024, 1, 1),
        'updated_at': DateTime(2024, 1, 1),
      });
      user.exists = true;
      user.syncOriginal();

      user.attributes['name'] = 'Updated';
      await user.save();

      final updateSql = dbSpy.history.firstWhere(
        (sql) => sql.contains('UPDATE "users"'),
      );

      expect(updateSql, isNot(contains('"created_at"')));
      expect(updateSql, contains('"updated_at"'));
    });
  });

  group('HasTimestamps Extended', () {
    test('created_at not overwritten if already set', () async {
      final existingDate = DateTime(2020, 5, 15);
      final user = TimestampUser({
        'name': 'David',
        'created_at': existingDate.toIso8601String(),
      });

      // Verifica che created_at sia preservato dopo onSaving
      await user.onSaving();

      // created_at dovrebbe essere quello originale, non uno nuovo
      final createdAtValue = user.attributes['created_at'];
      expect(createdAtValue, existingDate.toIso8601String());
    });

    test('updated_at always refreshed on save (even insert)', () async {
      final user = TimestampUser({'name': 'David'});

      await user.onSaving();

      // updated_at should be set to current time
      expect(user.attributes.containsKey('updated_at'), isTrue);
      expect(user.attributes['updated_at'], isNotNull);
    });

    test('timestamps disabled skips both columns', () async {
      final user = NoTimestampUser({'name': 'David'});

      await user.onSaving();

      // Con timestamps disabilitato, non dovrebbero essere aggiunti
      expect(user.attributes.containsKey('created_at'), isFalse);
      expect(user.attributes.containsKey('updated_at'), isFalse);
    });

    test('custom column names (createdAtColumn, updatedAtColumn)', () async {
      final user = CustomTimestampUser({'name': 'David'});

      await user.onSaving();

      // Dovrebbe usare i nomi custom
      expect(user.attributes.containsKey('date_created'), isTrue);
      expect(user.attributes.containsKey('date_modified'), isTrue);
      expect(user.attributes.containsKey('created_at'), isFalse);
      expect(user.attributes.containsKey('updated_at'), isFalse);
    });

    test('updated_at changes on every update', () async {
      final originalDate = DateTime(2024, 1, 1, 10, 0, 0);
      final user = TimestampUser({
        'id': 1,
        'name': 'David',
        'created_at': originalDate.toIso8601String(),
        'updated_at': originalDate.toIso8601String(),
      });
      user.exists = true;
      user.syncOriginal();

      await Future.delayed(const Duration(milliseconds: 10));

      user.attributes['name'] = 'Updated';
      await user.onSaving();

      // updated_at dovrebbe essere piÃ¹ recente
      final updatedAt = user.attributes['updated_at'];
      expect(updatedAt, isNot(equals(originalDate.toIso8601String())));
    });
  });
}


--- FILE: test/core/concerns/has_global_scopes_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class AgeScope implements Scope {
  @override
  void apply(QueryBuilder builder, Model model) {
    builder.where('age', 18, '>=');
  }
}

class ActiveScope implements Scope {
  @override
  void apply(QueryBuilder builder, Model model) {
    builder.where('is_active', 1);
  }
}

class ScopedUser extends Model with HasGlobalScopes {
  @override
  String get table => 'users';

  @override
  List<Scope> get globalScopes => [AgeScope(), ActiveScope()];

  ScopedUser([super.attributes]);
  @override
  ScopedUser fromMap(Map<String, dynamic> map) => ScopedUser(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Global Scopes', () {
    test('It applies registered scopes automatically', () async {
      await ScopedUser().query().get();

      expect(dbSpy.lastSql, contains('"age" >= ?'));
      expect(dbSpy.lastSql, contains('"is_active" = ?'));
      expect(dbSpy.lastArgs, contains(18));
      expect(dbSpy.lastArgs, contains(1));
    });

    test('withoutGlobalScopes() ignores all scopes', () async {
      await ScopedUser().withoutGlobalScopes().get();

      expect(dbSpy.lastSql, isNot(contains('"age" >=')));
      expect(dbSpy.lastSql, isNot(contains('"is_active" =')));
    });

    test('withoutGlobalScope<T>() ignores only specific scope', () async {
      await ScopedUser().withoutGlobalScope<AgeScope>().get();

      expect(dbSpy.lastSql, isNot(contains('"age" >=')));
      expect(dbSpy.lastSql, contains('"is_active" = ?'));
    });
  });
}


--- FILE: test/core/concerns/has_global_scopes_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class TenantScope implements Scope {
  final int tenantId;
  TenantScope(this.tenantId);

  @override
  void apply(QueryBuilder builder, Model model) {
    builder.where('tenant_id', tenantId);
  }
}

class ActiveScope implements Scope {
  @override
  void apply(QueryBuilder builder, Model model) {
    builder.where('is_active', 1);
  }
}

class AgeScope implements Scope {
  @override
  void apply(QueryBuilder builder, Model model) {
    builder.where('age', 18, '>=');
  }
}

class MultiScopeUser extends Model with HasGlobalScopes {
  @override
  String get table => 'users';

  @override
  List<Scope> get globalScopes => [TenantScope(42), ActiveScope(), AgeScope()];

  MultiScopeUser([super.attributes]);

  @override
  MultiScopeUser fromMap(Map<String, dynamic> map) => MultiScopeUser(map);
}

class NoScopeUser extends Model with HasGlobalScopes {
  @override
  String get table => 'users';

  @override
  List<Scope> get globalScopes => [];

  NoScopeUser([super.attributes]);

  @override
  NoScopeUser fromMap(Map<String, dynamic> map) => NoScopeUser(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy();
    DatabaseManager().setDatabase(dbSpy);
  });

  group('HasGlobalScopes Extended', () {
    test('multiple scopes applied in order', () async {
      await MultiScopeUser().query().get();

      // All three scopes should be applied
      expect(dbSpy.lastSql, contains('"tenant_id" = ?'));
      expect(dbSpy.lastSql, contains('"is_active" = ?'));
      expect(dbSpy.lastSql, contains('"age" >= ?'));

      // Bindings should be in order
      expect(dbSpy.lastArgs, equals([42, 1, 18]));
    });

    test('scope with dynamic parameters (TenantScope)', () async {
      await MultiScopeUser().query().get();

      expect(dbSpy.lastArgs, contains(42));
    });

    test('withoutGlobalScopes() with no scopes defined', () async {
      await NoScopeUser().withoutGlobalScopes().get();

      // Should work without error, no scopes applied
      expect(dbSpy.lastSql, isNot(contains('tenant_id')));
      expect(dbSpy.lastSql, isNot(contains('is_active')));
    });

    test('withoutGlobalScope<T>() with non-existent scope type', () async {
      // Trying to exclude a scope that doesn't exist
      await NoScopeUser().withoutGlobalScope<TenantScope>().get();

      // Should work without error
      expect(dbSpy.history, isNotEmpty);
    });

    test('withoutGlobalScope<T>() excludes only specific scope', () async {
      await MultiScopeUser().withoutGlobalScope<TenantScope>().get();

      // TenantScope should be excluded
      expect(dbSpy.lastSql, isNot(contains('tenant_id')));

      // Other scopes should still be applied
      expect(dbSpy.lastSql, contains('"is_active" = ?'));
      expect(dbSpy.lastSql, contains('"age" >= ?'));
    });

    test('withoutGlobalScopes() ignores all scopes', () async {
      await MultiScopeUser().withoutGlobalScopes().get();

      expect(dbSpy.lastSql, isNot(contains('tenant_id')));
      expect(dbSpy.lastSql, isNot(contains('is_active')));
      expect(dbSpy.lastSql, isNot(contains('age >=')));
    });

    test('scopes combined with additional where clauses', () async {
      await MultiScopeUser().query().where('name', 'David').get();

      // Scopes + manual where
      expect(dbSpy.lastSql, contains('"tenant_id" = ?'));
      expect(dbSpy.lastSql, contains('"name" = ?'));
    });
  });
}


--- FILE: test/core/concerns/has_uuids_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class UuidUser extends Model with HasUuids {
  @override
  String get table => 'users';

  UuidUser([super.attributes]);

  @override
  UuidUser fromMap(Map<String, dynamic> map) => UuidUser(map);
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'FROM users': [
        {'id': 'will-be-replaced', 'name': 'David'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);
  });

  group('HasUuids Mixin', () {
    test('UUID generated on first save', () async {
      final user = UuidUser({'name': 'David'});

      expect(user.id, isNull);

      await user.save();

      expect(user.id, isNotNull);
      expect(user.id, isA<String>());
      expect((user.id as String).length, greaterThan(0));
    });

    test('UUID not overwritten if already set', () async {
      final customUuid = 'my-custom-uuid-123';

      final mockDb = MockDatabaseSpy([], {
        'FROM users': [
          {'id': customUuid, 'name': 'David'},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = UuidUser({'id': customUuid, 'name': 'David'});

      await user.save();

      final insertSql = mockDb.history.firstWhere(
        (s) => s.contains('INSERT'),
        orElse: () => '',
      );
      expect(insertSql, contains('id'));

      expect(user.id, customUuid);
    });

    test('UUID format is valid v4 pattern', () async {
      final user = UuidUser({'name': 'David'});

      await user.onSaving();

      final generatedId = user.id as String?;

      // UUID v4 deve avere 36 caratteri (8-4-4-4-12)
      expect(generatedId, isNotNull);
      expect(generatedId!.length, 36);
      expect(generatedId.contains('-'), isTrue);

      // Verifica pattern UUID v4: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
      final uuidRegex = RegExp(
        r'^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',
        caseSensitive: false,
      );
      expect(uuidRegex.hasMatch(generatedId), isTrue);
    });

    test('incrementing returns false', () {
      final user = UuidUser();
      expect(user.incrementing, isFalse);
    });

    test('multiple saves keep same UUID', () async {
      final user = UuidUser({'name': 'David'});

      await user.onSaving();
      final firstId = user.id;

      expect(firstId, isNotNull);

      user.exists = true;
      user.syncOriginal();

      await user.onSaving();

      expect(user.id, firstId);
    });

    test('each new model generates different UUID', () async {
      final user1 = UuidUser({'name': 'User 1'});
      final user2 = UuidUser({'name': 'User 2'});

      await user1.onSaving();
      await user2.onSaving();

      expect(user1.id, isNotNull);
      expect(user2.id, isNotNull);
      expect(user1.id, isNot(equals(user2.id)));
    });
  });
}


--- FILE: test/core/concerns/has_soft_deletes_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class User extends Model with HasSoftDeletes {
  @override
  String get table => 'users';

  User([super.attributes]);

  @override
  User fromMap(Map<String, dynamic> map) => User(map);

  @override
  Map<String, String> get casts => {'deleted_at': 'datetime'};
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'SELECT "users".* FROM "users" WHERE "id" = ? LIMIT 1': [
        {'id': 1, 'name': 'David', 'deleted_at': '2023-01-01'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);
  });

  group('Soft Deletes Logic', () {
    test('delete() performs UPDATE on deleted_at instead of DELETE', () async {
      final user = User({'id': 1, 'name': 'David'});
      user.exists = true;
      user.syncOriginal();

      await user.delete();

      expect(dbSpy.history, contains(contains('UPDATE "users" SET')));
      expect(dbSpy.history, contains(contains('"deleted_at" = ?')));

      final hasDelete = dbSpy.history.any((sql) => sql.contains('DELETE FROM'));
      expect(hasDelete, isFalse);

      expect(user.trashed, isTrue);
    });

    test(
      'Standard query automatically excludes soft deleted records',
      () async {
        await User().query().get();
        expect(dbSpy.lastSql, contains('WHERE "deleted_at" IS NULL'));
      },
    );

    test('withTrashed() includes soft deleted records', () async {
      await User().withTrashed().get();
      expect(dbSpy.lastSql, isNot(contains('"deleted_at" IS NULL')));
    });

    test('onlyTrashed() fetches ONLY soft deleted records', () async {
      await User().onlyTrashed().get();
      expect(dbSpy.lastSql, contains('WHERE "deleted_at" IS NOT NULL'));
    });

    test('restore() resets deleted_at to NULL', () async {
      final restoreMock = MockDatabaseSpy([], {
        'SELECT "users".* FROM "users" WHERE "id" = ? LIMIT 1': [
          {'id': 1, 'name': 'David', 'deleted_at': null},
        ],
      });
      DatabaseManager().setDatabase(restoreMock);

      final user = User({'id': 1, 'deleted_at': '2023-01-01 10:00:00'});
      user.exists = true;
      user.syncOriginal();

      await user.restore();

      expect(restoreMock.history, contains(contains('UPDATE "users" SET')));

      expect(user.trashed, isFalse);
      expect(user.attributes['deleted_at'], isNull);
    });

    test('forceDelete() performs physical DELETE', () async {
      final user = User({'id': 1});
      user.exists = true;

      await user.forceDelete();

      expect(dbSpy.lastSql, contains('DELETE FROM "users"'));
      expect(dbSpy.lastSql, contains('WHERE "id" = ?'));
    });
  });
}


--- FILE: test/core/concerns/has_guards_attributes_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class FillableUser extends Model {
  @override
  String get table => 'users';

  @override
  List<String> get fillable => ['name', 'email', 'bio'];

  FillableUser([super.attributes]);

  @override
  FillableUser fromMap(Map<String, dynamic> map) => FillableUser(map);
}

class GuardedUser extends Model {
  @override
  String get table => 'users';

  @override
  List<String> get guarded => ['id', 'is_admin', 'api_key'];

  GuardedUser([super.attributes]);

  @override
  GuardedUser fromMap(Map<String, dynamic> map) => GuardedUser(map);
}

class TotallyGuardedUser extends Model {
  @override
  String get table => 'users';

  // Default: guarded => ['*']

  TotallyGuardedUser([super.attributes]);

  @override
  TotallyGuardedUser fromMap(Map<String, dynamic> map) =>
      TotallyGuardedUser(map);
}

class MixedUser extends Model {
  @override
  String get table => 'users';

  @override
  List<String> get fillable => ['name', 'email'];

  @override
  List<String> get guarded => ['is_admin']; // Should be ignored when fillable is set

  MixedUser([super.attributes]);

  @override
  MixedUser fromMap(Map<String, dynamic> map) => MixedUser(map);
}

void main() {
  setUp(() {
    HasGuardsAttributes.reguard();
    DatabaseManager().setDatabase(MockDatabaseSpy());
  });

  tearDown(() {
    HasGuardsAttributes.reguard();
  });

  group('HasGuardsAttributes Extended', () {
    test('fill() ignores keys not in fillable', () {
      final user = FillableUser();

      user.fill({
        'name': 'David',
        'email': 'david@test.com',
        'is_admin': true,
        'password': 'secret',
      });

      expect(user.attributes['name'], 'David');
      expect(user.attributes['email'], 'david@test.com');
      expect(user.attributes.containsKey('is_admin'), isFalse);
      expect(user.attributes.containsKey('password'), isFalse);
    });

    test('fill() with empty fillable blocks all (default behavior)', () {
      final user = TotallyGuardedUser();

      user.fill({'name': 'David', 'email': 'david@test.com'});

      expect(user.attributes, isEmpty);
    });

    test('fill() with guarded * blocks all', () {
      final user = TotallyGuardedUser();

      user.fill({'anything': 'value'});

      expect(user.attributes, isEmpty);
    });

    test('fill() with specific guarded keys', () {
      final user = GuardedUser();

      user.fill({
        'name': 'David',
        'email': 'david@test.com',
        'id': 999,
        'is_admin': true,
        'api_key': 'secret',
      });

      expect(user.attributes['name'], 'David');
      expect(user.attributes['email'], 'david@test.com');
      expect(user.attributes.containsKey('id'), isFalse);
      expect(user.attributes.containsKey('is_admin'), isFalse);
      expect(user.attributes.containsKey('api_key'), isFalse);
    });

    test('fillable takes precedence over guarded', () {
      final user = MixedUser();

      user.fill({
        'name': 'David',
        'email': 'david@test.com',
        'is_admin': true, // In guarded, but fillable takes precedence
        'other': 'value', // Not in fillable
      });

      expect(user.attributes['name'], 'David');
      expect(user.attributes['email'], 'david@test.com');
      // fillable whitelist means only those keys are allowed
      expect(user.attributes.containsKey('is_admin'), isFalse);
      expect(user.attributes.containsKey('other'), isFalse);
    });

    test('forceFill() sets guarded attributes', () {
      final user = TotallyGuardedUser();

      user.forceFill({'name': 'David', 'is_admin': true, 'api_key': 'secret'});

      expect(user.attributes['name'], 'David');
      expect(user.attributes['is_admin'], true);
      expect(user.attributes['api_key'], 'secret');
    });

    test('isFillable() returns correct boolean', () {
      final user = FillableUser();

      expect(user.isFillable('name'), isTrue);
      expect(user.isFillable('email'), isTrue);
      expect(user.isFillable('is_admin'), isFalse);
      expect(user.isFillable('anything'), isFalse);
    });

    test('isFillable() with guarded model', () {
      final user = GuardedUser();

      expect(user.isFillable('name'), isTrue);
      expect(user.isFillable('id'), isFalse);
      expect(user.isFillable('is_admin'), isFalse);
    });

    test('unguard() affects all model instances', () {
      HasGuardsAttributes.unguard();

      final user1 = TotallyGuardedUser();
      final user2 = FillableUser();

      user1.fill({'anything': 'value1'});
      user2.fill({'is_admin': true});

      expect(user1.attributes['anything'], 'value1');
      expect(user2.attributes['is_admin'], true);
    });

    test('reguard() restores protection', () {
      HasGuardsAttributes.unguard();

      final user1 = TotallyGuardedUser();
      user1.fill({'test': 'value'});
      expect(user1.attributes['test'], 'value');

      HasGuardsAttributes.reguard();

      final user2 = TotallyGuardedUser();
      user2.fill({'test': 'value'});
      expect(user2.attributes.containsKey('test'), isFalse);
    });

    test('fill() with nested objects', () {
      final user = FillableUser();

      user.fill({
        'name': 'David',
        'bio': 'Developer',
        'nested': {'key': 'value'}, // Not in fillable
      });

      expect(user.attributes['name'], 'David');
      expect(user.attributes['bio'], 'Developer');
      expect(user.attributes.containsKey('nested'), isFalse);
    });
  });
}


--- FILE: test/core/concerns/has_guards_attributes_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class WhiteListUser extends Model {
  @override
  String get table => 'users';

  @override
  List<String> get fillable => ['name', 'email', 'settings'];

  @override
  Map<String, String> get casts => {'settings': 'json'};

  WhiteListUser([super.attributes]);
  @override
  WhiteListUser fromMap(Map<String, dynamic> map) => WhiteListUser(map);
}

class BlackListUser extends Model {
  @override
  String get table => 'users';

  @override
  List<String> get guarded => ['is_admin', 'secret_key', 'id'];

  BlackListUser([super.attributes]);
  @override
  BlackListUser fromMap(Map<String, dynamic> map) => BlackListUser(map);
}

class DefaultSecureUser extends Model {
  @override
  String get table => 'users';

  DefaultSecureUser([super.attributes]);
  @override
  DefaultSecureUser fromMap(Map<String, dynamic> map) => DefaultSecureUser(map);
}

void main() {
  setUp(() {
    HasGuardsAttributes.reguard();
    DatabaseManager().setDatabase(MockDatabaseSpy());
  });

  group('GuardsAttributes (Mass Assignment)', () {
    test('fill() only allows attributes in fillable array', () {
      final user = WhiteListUser();

      final input = {
        'name': 'David',
        'email': 'david@test.com',
        'is_admin': true,
        'role': 'editor',
      };

      user.fill(input);

      expect(user.attributes['name'], 'David');
      expect(user.attributes['email'], 'david@test.com');

      expect(user.attributes.containsKey('is_admin'), isFalse);
      expect(user.attributes.containsKey('role'), isFalse);
    });

    test('fill() blocks attributes in guarded array', () {
      final user = BlackListUser();

      final input = {
        'name': 'Romolo',
        'is_admin': true,
        'secret_key': '12345',
        'id': 99,
      };

      user.fill(input);

      expect(user.attributes['name'], 'Romolo');
      expect(user.attributes.containsKey('is_admin'), isFalse);
      expect(user.attributes.containsKey('secret_key'), isFalse);
      expect(user.attributes.containsKey('id'), isFalse);
    });

    test('Models are totally guarded by default if nothing is configured', () {
      final user = DefaultSecureUser();

      user.fill({'name': 'Hacker', 'admin': true});

      expect(user.attributes, isEmpty);
    });

    test('fill() uses setAttribute internally respecting Casts', () {
      final user = WhiteListUser();

      final input = {
        'settings': {'theme': 'dark', 'notifications': true},
      };

      user.fill(input);

      expect(user.attributes['settings'], isA<String>());
      expect(user.attributes['settings'], contains('"theme":"dark"'));
    });

    test('forceFill() bypasses protection', () {
      final user = WhiteListUser();

      final input = {'name': 'David', 'is_admin': true};

      user.forceFill(input);

      expect(user.attributes['name'], 'David');
      expect(user.attributes['is_admin'], true);
    });

    test('unguard() disables protection globally', () {
      HasGuardsAttributes.unguard();

      final user = WhiteListUser();

      user.fill({'is_admin': true});

      expect(user.attributes['is_admin'], true);

      HasGuardsAttributes.reguard();

      final user2 = WhiteListUser();
      user2.fill({'is_admin': true});

      expect(user2.attributes.containsKey('is_admin'), isFalse);
    });
  });
}


--- FILE: test/core/concerns/has_soft_deletes_extended_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

class SoftUser extends Model with HasSoftDeletes {
  @override
  String get table => 'users';

  bool onDeletingCalled = false;
  bool onDeletedCalled = false;

  SoftUser([super.attributes]);

  @override
  SoftUser fromMap(Map<String, dynamic> map) => SoftUser(map);

  @override
  Map<String, String> get casts => {'deleted_at': 'datetime'};

  @override
  Future<bool> onDeleting() async {
    onDeletingCalled = true;
    return super.onDeleting();
  }

  @override
  Future<void> onDeleted() async {
    onDeletedCalled = true;
    await super.onDeleted();
  }
}

void main() {
  late MockDatabaseSpy dbSpy;

  setUp(() {
    dbSpy = MockDatabaseSpy([], {
      'SELECT users.* FROM users WHERE id = ? LIMIT 1': [
        {'id': 1, 'name': 'David', 'deleted_at': '2023-01-01'},
      ],
    });
    DatabaseManager().setDatabase(dbSpy);
  });

  group('HasSoftDeletes Extended', () {
    test('trashed getter returns true when deleted_at is set', () {
      final user = SoftUser({'id': 1, 'deleted_at': '2023-01-01T10:00:00'});
      expect(user.trashed, isTrue);
    });

    test('trashed getter returns false when deleted_at is null', () {
      final user = SoftUser({'id': 1, 'deleted_at': null});
      expect(user.trashed, isFalse);
    });

    test('trashed getter returns false when deleted_at is missing', () {
      final user = SoftUser({'id': 1});
      expect(user.trashed, isFalse);
    });

    test('delete() on new model (exists=false, no id) does nothing', () async {
      final user = SoftUser({'name': 'David'});
      // id is null, exists is false

      await user.delete();

      expect(dbSpy.history, isEmpty);
    });

    test('restore() clears deleted_at', () async {
      final restoreMock = MockDatabaseSpy([], {
        'SELECT users.* FROM users WHERE id = ? LIMIT 1': [
          {'id': 1, 'name': 'David', 'deleted_at': null},
        ],
      });
      DatabaseManager().setDatabase(restoreMock);

      final user = SoftUser({'id': 1, 'deleted_at': '2023-01-01T10:00:00'});
      user.exists = true;
      user.syncOriginal();

      await user.restore();

      expect(user.trashed, isFalse);
      expect(user.attributes['deleted_at'], isNull);
    });

    test('restore() on non-trashed model still saves', () async {
      final mockDb = MockDatabaseSpy([], {
        'SELECT * FROM users WHERE id = ?': [
          {'id': 1, 'name': 'David', 'deleted_at': null},
        ],
      });
      DatabaseManager().setDatabase(mockDb);

      final user = SoftUser({'id': 1, 'deleted_at': null});
      user.exists = true;
      user.syncOriginal();

      await user.restore();

      // Should still attempt to save (no-op due to no dirty fields)
      expect(user.trashed, isFalse);
    });

    test('forceDelete() removes from DB permanently', () async {
      final user = SoftUser({'id': 1});
      user.exists = true;

      await user.forceDelete();

      expect(dbSpy.lastSql, contains('DELETE FROM "users"'));
      expect(dbSpy.lastSql, contains('WHERE "id" = ?'));
    });

    test('forceDelete() triggers onDeleting/onDeleted hooks', () async {
      final user = SoftUser({'id': 1});
      user.exists = true;

      await user.forceDelete();

      expect(user.onDeletingCalled, isTrue);
      expect(user.onDeletedCalled, isTrue);
    });

    test('withTrashed() combined with where clauses', () async {
      await SoftUser().withTrashed().where('name', 'David').get();

      expect(dbSpy.lastSql, contains('WHERE "name" = ?'));
      expect(dbSpy.lastSql, isNot(contains('"deleted_at" IS NULL')));
    });

    test('onlyTrashed() combined with where clauses', () async {
      await SoftUser().onlyTrashed().where('role', 'admin').get();

      expect(dbSpy.lastSql, contains('WHERE "deleted_at" IS NOT NULL'));
      expect(dbSpy.lastSql, contains('AND "role" = ?'));
    });

    test('standard query excludes soft deleted records', () async {
      await SoftUser().query().get();

      expect(dbSpy.lastSql, contains('WHERE "deleted_at" IS NULL'));
    });
  });
}


--- FILE: test/core/concerns/has_casts_test.dart ---
import 'package:test/test.dart';
import 'package:bavard/bavard.dart';
import 'package:bavard/testing.dart';

enum UserStatus { active, inactive, pending }

enum Priority { low, medium, high }

class CastUser extends Model {
  @override
  String get table => 'users';

  CastUser([super.attributes]);

  @override
  CastUser fromMap(Map<String, dynamic> map) => CastUser(map);

  @override
  Map<String, String> get casts => {
    'age': 'int',
    'score': 'double',
    'is_active': 'bool',
    'created_at': 'datetime',
    'settings': 'json',
    'tags': 'array',
    'metadata': 'object',
    'nullable_int': 'int?',
    'required_int': 'int!',
  };
}

class JsonModel {
  final String name;
  final int value;

  JsonModel(this.name, this.value);

  Map<String, dynamic> toJson() => {'name': name, 'value': value};
}

void main() {
  setUp(() {
    DatabaseManager().setDatabase(MockDatabaseSpy());
  });

  // ===========================================================================
  // TYPE CASTING - READ
  // ===========================================================================
  group('getAttribute - Integer', () {
    test('getAttribute int from string', () {
      final user = CastUser({'age': '25'});
      expect(user.getAttribute<int>('age'), 25);
    });

    test('getAttribute int from int (passthrough)', () {
      final user = CastUser({'age': 30});
      expect(user.getAttribute<int>('age'), 30);
    });

    test('getAttribute int from invalid string returns null', () {
      final user = CastUser({'age': 'not-a-number'});
      expect(user.getAttribute<int>('age'), isNull);
    });

    test(
      'getAttribute int from double string returns null (int.tryParse limitation)',
      () {
        final user = CastUser({'age': '25.9'});
        final result = user.getAttribute<int>('age');

        // int.tryParse('25.9') returns null because it cannot parse decimal strings
        // This is the expected behavior of the current implementation
        // Return null
        // TODO: Change?
        expect(result, isNull);
      },
    );
  });

  group('getAttribute - Double', () {
    test('getAttribute double from string', () {
      final user = CastUser({'score': '99.5'});
      expect(user.getAttribute<double>('score'), 99.5);
    });

    test('getAttribute double from int', () {
      final user = CastUser({'score': 100});
      expect(user.getAttribute<double>('score'), 100.0);
    });

    test('getAttribute double from double (passthrough)', () {
      final user = CastUser({'score': 88.8});
      expect(user.getAttribute<double>('score'), 88.8);
    });

    test('getAttribute double from invalid string returns null', () {
      final user = CastUser({'score': 'invalid'});
      expect(user.getAttribute<double>('score'), isNull);
    });
  });

  group('getAttribute - Boolean', () {
    test('getAttribute bool from int 1', () {
      final user = CastUser({'is_active': 1});
      expect(user.getAttribute<bool>('is_active'), isTrue);
    });

    test('getAttribute bool from int 0', () {
      final user = CastUser({'is_active': 0});
      expect(user.getAttribute<bool>('is_active'), isFalse);
    });

    test('getAttribute bool from string "true"', () {
      final user = CastUser({'is_active': 'true'});
      expect(user.getAttribute<bool>('is_active'), isTrue);
    });

    test('getAttribute bool from string "false"', () {
      final user = CastUser({'is_active': 'false'});
      expect(user.getAttribute<bool>('is_active'), isFalse);
    });

    test('getAttribute bool from string "1"', () {
      final user = CastUser({'is_active': '1'});
      expect(user.getAttribute<bool>('is_active'), isTrue);
    });

    test('getAttribute bool from string "0"', () {
      final user = CastUser({'is_active': '0'});
      expect(user.getAttribute<bool>('is_active'), isFalse);
    });

    test('getAttribute bool from bool (passthrough)', () {
      final user = CastUser({'is_active': true});
      expect(user.getAttribute<bool>('is_active'), isTrue);
    });

    test('getAttribute bool from string "TRUE" (case insensitive)', () {
      final user = CastUser({'is_active': 'TRUE'});
      expect(user.getAttribute<bool>('is_active'), isTrue);
    });
  });

  group('getAttribute - DateTime', () {
    test('getAttribute datetime from ISO string', () {
      final user = CastUser({'created_at': '2024-06-15T10:30:00.000'});
      final dt = user.getAttribute<DateTime>('created_at');

      expect(dt, isA<DateTime>());
      expect(dt?.year, 2024);
      expect(dt?.month, 6);
      expect(dt?.day, 15);
    });

    test('getAttribute datetime from DateTime (passthrough)', () {
      final now = DateTime.now();
      final user = CastUser({'created_at': now});

      expect(user.getAttribute<DateTime>('created_at'), now);
    });

    test('getAttribute datetime from invalid string returns null', () {
      final user = CastUser({'created_at': 'not-a-date'});
      expect(user.getAttribute<DateTime>('created_at'), isNull);
    });

    test('getAttribute datetime from date-only string', () {
      final user = CastUser({'created_at': '2024-01-15'});
      final dt = user.getAttribute<DateTime>('created_at');

      expect(dt?.year, 2024);
      expect(dt?.month, 1);
      expect(dt?.day, 15);
    });
  });

  group('getAttribute - JSON/Array/Object', () {
    test('getAttribute json from valid JSON string', () {
      final user = CastUser({'settings': '{"theme":"dark","lang":"en"}'});
      final settings = user.getAttribute<Map<String, dynamic>>('settings');

      expect(settings, isA<Map<String, dynamic>>());
      expect(settings?['theme'], 'dark');
    });

    test('getAttribute json from invalid JSON returns null', () {
      final user = CastUser({'settings': 'not valid json {'});
      expect(user.getAttribute('settings'), isNull);
    });

    test('getAttribute json from Map (passthrough)', () {
      final user = CastUser({
        'settings': {'theme': 'light'},
      });
      final settings = user.getAttribute<Map<String, dynamic>>('settings');

      expect(settings?['theme'], 'light');
    });

    test('getAttribute array from JSON array string', () {
      final user = CastUser({'tags': '["flutter","dart","orm"]'});
      final tags = user.getAttribute<List<dynamic>>('tags');

      expect(tags, isA<List>());
      expect(tags, contains('flutter'));
      expect(tags?.length, 3);
    });

    test('getAttribute array from List (passthrough)', () {
      final user = CastUser({
        'tags': ['a', 'b', 'c'],
      });
      final tags = user.getAttribute<List>('tags');

      expect(tags?.length, 3);
    });

    test('getAttribute object from JSON object string', () {
      final user = CastUser({'metadata': '{"version":1,"flag":true}'});
      final meta = user.getAttribute<Map<String, dynamic>>('metadata');

      expect(meta?['version'], 1);
      expect(meta?['flag'], true);
    });
  });

  group('getAttribute - Edge Cases', () {
    test('getAttribute with unknown cast type returns raw value', () {
      final user = CastUser({'unknown': 'raw_value'});
      expect(user.getAttribute('unknown'), 'raw_value');
    });

    test('getAttribute returns null for missing key', () {
      final user = CastUser({});
      expect(user.getAttribute('nonexistent'), isNull);
    });

    test('getAttribute returns null for null value', () {
      final user = CastUser({'age': null});
      expect(user.getAttribute<int>('age'), isNull);
    });
  });

  // ===========================================================================
  // TYPE CASTING - WRITE
  // ===========================================================================
  group('setAttribute - JSON Encoding', () {
    test('setAttribute encodes Map to JSON string', () {
      final user = CastUser();
      user.setAttribute('settings', {'theme': 'dark'});

      expect(user.attributes['settings'], isA<String>());
      expect(user.attributes['settings'], contains('"theme":"dark"'));
    });

    test('setAttribute encodes List to JSON string', () {
      final user = CastUser();
      user.setAttribute('tags', ['a', 'b', 'c']);

      expect(user.attributes['tags'], isA<String>());
      expect(user.attributes['tags'], '["a","b","c"]');
    });

    test('setAttribute encodes nested objects to JSON', () {
      final user = CastUser();
      user.setAttribute('settings', {
        'nested': {'deep': true},
      });

      expect(user.attributes['settings'], contains('"nested"'));
      expect(user.attributes['settings'], contains('"deep":true'));
    });

    test('setAttribute calls toJson() on custom objects', () {
      final user = CastUser();
      final obj = JsonModel('test', 42);
      user.setAttribute('settings', obj);

      expect(user.attributes['settings'], '{"name":"test","value":42}');
    });

    test('setAttribute preserves JSON string as-is', () {
      final user = CastUser();
      user.setAttribute('settings', '{"already":"json"}');

      expect(user.attributes['settings'], '{"already":"json"}');
    });
  });

  group('setAttribute - Primitives', () {
    test('setAttribute encodes bool true to 1', () {
      final user = CastUser();
      user.setAttribute('is_active', true);

      expect(user.attributes['is_active'], 1);
    });

    test('setAttribute encodes bool false to 0', () {
      final user = CastUser();
      user.setAttribute('is_active', false);

      expect(user.attributes['is_active'], 0);
    });

    test('setAttribute encodes DateTime to ISO string', () {
      final user = CastUser();
      final dt = DateTime(2024, 6, 15, 10, 30, 0);
      user.setAttribute('created_at', dt);

      expect(user.attributes['created_at'], '2024-06-15T10:30:00.000');
    });

    test('setAttribute with null value', () {
      final user = CastUser({'age': 25});
      user.setAttribute('age', null);

      expect(user.attributes['age'], isNull);
    });

    test('setAttribute preserves int as int', () {
      final user = CastUser();
      user.setAttribute('age', 30);

      expect(user.attributes['age'], 30);
      expect(user.attributes['age'], isA<int>());
    });

    test('setAttribute preserves string as string', () {
      final user = CastUser();
      user.setAttribute('name', 'David');

      expect(user.attributes['name'], 'David');
    });
  });

  group('setAttribute - Enum', () {
    test('setAttribute encodes Enum to name string', () {
      final user = CastUser();
      user.setAttribute('status', UserStatus.active);

      expect(user.attributes['status'], 'active');
    });

    test('setAttribute encodes different enum values', () {
      final user = CastUser();

      user.setAttribute('status', Priority.high);
      expect(user.attributes['status'], 'high');

      user.setAttribute('status', Priority.low);
      expect(user.attributes['status'], 'low');
    });
  });

  // ===========================================================================
  // ENUM HANDLING (getEnum)
  // ===========================================================================
  group('getEnum', () {
    test('getEnum with valid int index', () {
      final user = CastUser({'status': 0});
      final status = user.getEnum('status', UserStatus.values);

      expect(status, UserStatus.active);
    });

    test('getEnum with out-of-bounds index returns null', () {
      final user = CastUser({'status': 99});
      final status = user.getEnum('status', UserStatus.values);

      expect(status, isNull);
    });

    test('getEnum with negative index returns null', () {
      final user = CastUser({'status': -1});
      final status = user.getEnum('status', UserStatus.values);

      expect(status, isNull);
    });

    test('getEnum with valid string name', () {
      final user = CastUser({'status': 'pending'});
      final status = user.getEnum('status', UserStatus.values);

      expect(status, UserStatus.pending);
    });

    test('getEnum with invalid string name returns null', () {
      final user = CastUser({'status': 'unknown'});
      final status = user.getEnum('status', UserStatus.values);

      expect(status, isNull);
    });

    test('getEnum with null value returns null', () {
      final user = CastUser({'status': null});
      final status = user.getEnum('status', UserStatus.values);

      expect(status, isNull);
    });

    test('getEnum with missing key returns null', () {
      final user = CastUser({});
      final status = user.getEnum('status', UserStatus.values);

      expect(status, isNull);
    });
  });
}

>>>
